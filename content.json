[{"title":"select,poll和epoll","date":"2017-05-17T02:18:12.000Z","path":"2017/05/17/select-poll和epoll-1/","text":"selectselect函数允许进程指示内核等待多个事件中的任何一个发生,只有在一个或多个事件(描述符状态变化)发生或者阻塞时间超时会返回.select的接口如下: #include&lt;sys/select.h&gt; #include&lt;sys/time.h&gt; int select(int maxfdp1,fd_set* readset,fd_set* writeset,fd_set* exceptset,const struct timeval* timeout); 其中第一个参数表示所有关心的描述符总数,即后面三个集合中描述符的数量和,后面三个参数分别表示测试读写和异常条件的描述符.最后一个参数表示最大阻塞时间,即超过时间没有描述符就绪则返回. struct timeval{ long tv_sec;// 秒数 long tv_usec;// 微妙数 }; fd_set这个结构的初始化和赋值使用已定义的宏: void FD_ZERO(fd_set \\*fdset); //初始化清零 void FD_SET(int fd,FD_SET \\*fdset); //设置某一位描述符 void FD_CLR(int fd,FD_SET \\*fdset); //清除某一位描述符 int FD_ISSET(int fd,FD_SET \\*fdset); //测试是否有指定位描述符 对于select返回某个套接字就绪的条件,总结如下: 条件 可读吗? 可写吗? 异常吗? 有数据可读 Y 关闭连接的读一半 Y 给监听套接口准备好新连接 Y 有可用于写的空间 Y 关闭连接的写一半 Y 待处理错误 Y Y TCP带外数据 Y 说明:关闭套接字的读一半后,执行读操作会立即返回EOF,所以也算作可读状态,关闭写一半,执行写操作会立即返回SIGPIPE信号,算作可写状态. pollpoll功能和select相似,在处理流设备时,能提供额外信息.poll函数接口原型: #include&lt;poll.h&gt; int poll(struct pollfd *fdarray,unsigned long nfds,int timeout); 结构体 pollfd的定义: struct pollfd{ int fd; //要测试的描述符 short events; //感兴趣的事件(读写异常) short revents; //发生的事件 }; POSIX定义了events标志的一些常值 常值 作为events输入吗 作为revents输出吗 说明 POLLIN Y Y 普通或优先级带数据可读 POLLRDNORM Y Y 普通数据可读 POLLOUT Y Y 普通数据可写 POLLERR Y 发生错误 参数nfds表示套接字的数量 epollselect的缺点有两个,第一,针对每个描述符的循环语句.第二,每次调用都要向操作系统传递套接字信息,造成无法优化的负担.为了解决第二个问题,epoll仅向操作系统传递一次监视对象,监视范围或者内容发生变化式只通知发生变化的事项(注意,Linux才支持epoll)epoll实现需要3个函数接口: epoll_create:创建保存epoll文件描述符的空间 epoll_ctl:向空间注册并注销文件描述符 epoll_wait:与select函数类似,等待文件描述符的变化.12345678910111213141516#include&lt;sys/epoll.h&gt;int epoll_create(int size);//成功返回文件描述符，创建的fd保存空间在内核中，size为建议的空间大小，用完需要调用close关闭.int epoll_ctl(int epfd,int op,int fd,struct epoll_event \\*event);//用来添加需要监视的fd。int epoll_wait(int epfd,struct epoll_event \\*events,int maxevents,int timeout);//成功返回就绪fd数量struct epoll_event&#123; __uint32_t events; epoll_data_t data;&#125;typedef union epoll_data&#123; void* ptr; int fd; __uint32_t u32; __uint64_t u64;&#125;epoll_data_t; epoll_ctl中op选项: EPOLL_CTL_ADD EPOLL_CTL_DEL EPOLL_CTL_MOD:更改出册的文件描述符的关注事件发生情况 epoll_events中的events常用值: EPOLLIN:需要读取数据的情况 EPOLLOUT:输出缓冲为空,可以立即发送数据的情况 EPOLLRDHUP:断开连接或者半关闭的情况 EPOLLERR:错误情况 EPOLLLET:以边缘触发的方式 EPOLLONESHOT:发生一次事件后,相应描述符不在收到事件通知(所以需要EPOLL_CTL_MOD选项.再次设置) epoll_wait中events保存就绪的描述符,所以需要给它动态分配缓存区,maxevents用来指示第二个参数最大数量. #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;sys/socket.h&gt; #include&lt;sys/epoll.h&gt; #include&lt;arpa/inet.h&gt; #include&lt;unistd.h&gt; #include&lt;string.h&gt; const int BUF_SIZE=100; const int EPOLL_SIZE=50; void error_handling(const char* message); int main(int argc,char** argv) { int serv_sock,clnt_sock; struct sockaddr_in serv_adr,clnt_adr; char buf[BUF_SIZE]; struct epoll_event* ep_events; struct epoll_event event; int epfd,event_cnt; if(argc!=2){ printf(&quot;Usage: %s&lt;port&gt;\\n&quot;,argv[0]); exit(1); } serv_sock=socket(PF_INET,SOCK_STREAM,0); memset(&amp;serv_adr,0,sizeof(serv_adr)); serv_adr.sin_family=AF_INET; serv_adr.sin_addr.s_addr=htonl(INADDR_ANY); serv_adr.sin_port=htons(atoi(argv[1])); if(bind(serv_sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr))==-1) error_handling(&quot;bind() error&quot;); if(listen(serv_sock,5)==-1) error_handling(&quot;listen() error&quot;); //创建epoll epfd=epoll_create(EPOLL_SIZE); ep_events=(struct epoll_event*)malloc(sizeof(struct epoll_event)*EPOLL_SIZE); event.events=EPOLLIN; event.data.fd=serv_sock; epoll_ctl(epfd,EPOLL_CTL_ADD,serv_sock,&amp;event); //监听 while(1) { event_cnt=epoll_wait(epfd,ep_events,EPOLL_SIZE,-1); if(event_cnt==-1){ puts(&quot;epoll_wait() error&quot;); break; } for(int i=0;i&lt;event_cnt;i++){ if(ep_events[i].data.fd==serv_sock) { socklen_t adr_sz=sizeof(clnt_adr); clnt_sock=accept(serv_sock,(struct sockaddr*)&amp;clnt_adr,&amp;adr_sz); event.events=EPOLLIN; event.data.fd=clnt_sock; epoll_ctl(epfd,EPOLL_CTL_ADD,clnt_sock,&amp;event); printf(&quot;connected client: %d \\n&quot;,clnt_sock); }else{ int str_len=read(ep_events[i].data.fd,buf,BUF_SIZE); if(str_len==0) { epoll_ctl(epfd,EPOLL_CTL_DEL,ep_events[i].data.fd,NULL); close(ep_events[i].data.fd); printf(&quot;Disconnected client: %d \\n&quot;,ep_events[i].data.fd); }else{ write(ep_events[i].data.fd,buf,str_len); } } } } close(serv_sock); close(epfd); return 0; } void error_handling(const char* message){ fputs(message,stderr); fputc(&apos;\\n&apos;,stderr); exit(1); } 条件触发和边缘出发条件触发:只要满足条件,就触发一个事件(例如缓冲区的数据没有读完,内核会一直通知)边缘触发:每当状态变化时,触发一个事件. “举个读socket的例子，假定经过长时间的沉默后，现在来了100个字节，这时无论边缘触发和条件触发都会产生一个read ready notification通知应用程序可读。应用程序读了50个字节，然后重新调用api等待io事件。这时水平触发的api会因为还有50个字节可读从 而立即返回用户一个read ready notification。而边缘触发的api会因为可读这个状态没有发生变化而陷入长期等待。 因此在使用边缘触发的api时，要注意每次都要读到socket返回EWOULDBLOCK为止，否则这个socket就算废了。而使用条件触发的api 时，如果应用程序不需要写就不要关注socket可写的事件，否则就会无限次的立即返回一个write ready notification。大家常用的select就是属于水平触发这一类，长期关注socket写事件会出现CPU 100%的毛病。 引用自网友博客的总结:epoll的优点：1.支持一个进程打开大数目的socket描述符(FD) select 最不能忍受的是一个进程所打开的FD是有一定限制的，由FD_SETSIZE设置，默认值是2048。对于那些需要支持的上万连接数目的IM服务器来说显 然太少了。这时候你一是可以选择修改这个宏然后重新编译内核，不过资料也同时指出这样会带来网络效率的下降，二是可以选择多进程的解决方案(传统的 Apache方案)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完 美的方案。不过 epoll则没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。 2.IO效率不随FD数目增加而线性下降 传统的select/poll另一个致命弱点就是当你拥有一个很大的socket集合，不过由于网络延时，任一时间只有部分的socket是”活跃”的， 但是select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。但是epoll不存在这个问题，它只会对”活跃”的socket进行 操作—这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有”活跃”的socket才会主动的去调用 callback函数，其他idle状态socket则不会，在这点上，epoll实现了一个”伪”AIO，因为这时候推动力在os内核。在一些 benchmark中，如果所有的socket基本上都是活跃的—比如一个高速LAN环境，epoll并不比select/poll有什么效率，相 反，如果过多使用epoll_ctl,效率相比还有稍微的下降。但是一旦使用idle connections模拟WAN环境,epoll的效率就远在select/poll之上了。 3.使用mmap加速内核与用户空间的消息传递。 这点实际上涉及到epoll的具体实现了。无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就 很重要，在这点上，epoll是通过内核于用户空间mmap同一块内存实现的。而如果你想我一样从2.5内核就关注epoll的话，一定不会忘记手工 mmap这一步的。 4.内核微调 这一点其实不算epoll的优点了，而是整个linux平台的优点。也许你可以怀疑linux平台，但是你无法回避linux平台赋予你微调内核的能力。 比如，内核TCP/IP协议栈使用内存池管理sk_buff结构，那么可以在运行时期动态调整这个内存pool(skb_head_pool)的大小 — 通过echo XXXX&gt;/proc/sys/net/core/hot_list_length完成。再比如listen函数的第2个参数(TCP完成3次握手 的数据包队列长度)，也可以根据你平台内存大小动态调整。更甚至在一个数据包面数目巨大但同时每个数据包本身大小却很小的特殊系统上尝试最新的NAPI网 卡驱动架构。","tags":[{"name":"unp","slug":"unp","permalink":"http://yoursite.com/tags/unp/"},{"name":"unix","slug":"unix","permalink":"http://yoursite.com/tags/unix/"}]},{"title":"5种IO模型总结","date":"2017-05-16T10:20:02.000Z","path":"2017/05/16/5种IO模型总结-1/","text":"在unix环境下,有5种IO模型,前4种属于同步IO: 阻塞式IO 非阻塞式IO IO复用(select和poll,还有更好的epoll) 信号驱动式IO(SIGIO) 异步IO(aio_系列函数) 阻塞式IO最流行的IO模型,默认情况下,所有套接字都是阻塞的,例如read,write,recvfrom.不再赘述(要注意不等于同步) 非阻塞式IO进程把一个套接字设置成非阻塞是在通知内核:当所请求的IO操作非得把本进程投入睡眠才能完成时,不要把本进程投入睡眠,而是返回一个错误.例如调用recvfrom时,如果内核空间无数据报准备好,则立即返回EWOULDBLOCK错误.如果有的话就会阻塞一直到IO完成.(按理论来说这种也属于同步IO)当一个应用进程对一个非阻塞描述符循环调用recvfrom时,称之为轮询,缺点式耗费cpu. IO复用模型调用select,系统阻塞在这个系统调用上,而不是真正的IO系统调用上,例如进程调用select,等待任一套接字变可读,一旦返回说明某个套接字的状态发生了变化,之后继续处理. 信号驱动式即让内核在描述符就绪时发送信号SIGIO通知进程,可以通过开启套接字的信号驱动式IO功能,通过sigaction系统调用安装一个信号处理函数.这种优势在于等待数据报到达期间进程不被阻塞. 异步IO模型告知内核某个操作,并让内核在整个操作完成后再通知进程. 总结:前四种IO的第一步各不相同,但第二部都一样,都会阻塞等待IO完成.但第五种不会阻塞.","tags":[{"name":"unp","slug":"unp","permalink":"http://yoursite.com/tags/unp/"},{"name":"unix","slug":"unix","permalink":"http://yoursite.com/tags/unix/"},{"name":"socket","slug":"socket","permalink":"http://yoursite.com/tags/socket/"}]},{"title":"字符串匹配KMP算法","date":"2017-03-28T06:09:15.000Z","path":"2017/03/28/字符串匹配KMP算法/","text":"题目:给定一个待匹配字符串和一个模板字符串,要求找到该串中模板字符串首次出现的位置,如果没有则返回-1. 第一种方法:朴素字符串匹配算法,也就是暴力枚举法,对需要匹配的字符串的每个字符进行一次匹配(在这里一次匹配操作是指两个等长字符串匹配),伪代码如下: 123456NAIVE_STRING_MATCHER(T,P)n=T.lengthm=P.lengthfor s=0 to n-m ifP[1..m]==T[s+1..s+m]return s; 其中第五行的操作记为比较两个等长字符串是否相等.类似于strcmp()函数,这些都很好理解,strcmp()复杂度最高为O(L)(L为待匹配字符串长度).所以整个算法时间复杂度为O(M*N) 第二种方法:KMP算法,为了由于朴素算法每一次的不匹配只移动一个偏移量,这会导致之前的已匹配区域重复匹配,为了能确定不匹配时该移动多少偏移量从而能利用之前的信息,所以我们需要一个next数组,也就是能确定当字符不匹配时,模板字符串向右移多少偏移量(数组的值真正记录的是在该位置前缀后缀最大公共长度,也就是该位置长度减去需要的偏移量).举个例子来说: 假设字符串”ababcba”,模板字符串是”abc”, 首先 a b c b a b a 由于c和a不等(此时位置在b,我们确定的是下一个字符匹配) 于是我们只移动模板2个偏移量,继续匹配 a b a a b c b a b a对应于next[2]=0(2-2); a b c 所以关键就是计算next数组. next数组计算伪代码如下: 123456789101112 COMPUTE_PREFIX_FUNCITION(P) m=P.length let next[1..m] be a new array next[1]=0 k=0 for q=2 to m while k&gt;0 and P[k+1]!=P[q] k=next[k] if P[k+1]==P[q] k=k+1next[q]=k; return next; 算法关键就在于第7-8行,while循环的总时间为O(m),从观察k的值开始,第一,在第5行,k初始值为0,并且增加k的唯一方法是通过第10行的递增操作,该操作在第6-11行的for循环中每次最多执行一次,因为k最多增加m-1次,第二,刚进行for循环时,k小于q,并且每次循环q都会增加,所以k永远小于q因此next[q]永远小于q,所以while循环会使q递减.所以while循环最多迭代m-1次. 下面是之前那道题的两种解法:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/*完成函数int strStr(const string&amp; str1,const string str2)功能,找到str1中子串str2的首字符出现的位置,如果没有则返回0 * 暴力解法O(m*n),也可以利用高效的字符串匹配算法例如KMP算法.*/#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;class Solution&#123;public: int strStr(const string&amp; haystack,const string&amp; needle)&#123; if(needle.empty())return 0; auto pos=haystack.begin(); const int N=haystack.size()-needle.size()+1; for(int i=0;i&lt;N;i++)&#123; int j=i; int k=0; while(j&lt;haystack.size()&amp;&amp;k&lt;needle.size()&amp;&amp;haystack[j]==needle[k])&#123; k++; j++; &#125; if(k==needle.size()) return i; &#125; return -1; &#125;&#125;;/*KMP算法.时间复杂度O(M+N),空间复杂度O(M)*/class Solution&#123;public: //KMP主程序,用预处理过的next数组来控制每次不匹配的偏移量,如果莫一个字符不匹配,那么直接找到needle中某一个字符和haystack的下一个字符匹配,这样永远不会回头,总匹配次数最多为字符串长度. int strStr(const string&amp; haystack,const string&amp; needle)&#123; if(needle.size()==0)return 0; vector&lt;int&gt; next=compute_next(needle); int q=-1; for(int i=0;i&lt;haystack.size();i++)&#123; while(q&gt;-1&amp;&amp;haystack[i]!=needle[q+1]) q=next[q]; if(haystack[i]==needle[q+1]) q++; if(q==(needle.size()-1)) return i-q; &#125;return -1; &#125;//用来计算next数组的算法.具体原理参照算法导论32章. static vector&lt;int&gt; compute_next(const string&amp; s)&#123; vector&lt;int&gt; next(s.size(),-1); if(s.size()==0)return next; int q=-1; for(int i=1;i&lt;s.size();i++)&#123; while(q&gt;-1&amp;&amp;s[i]!=s[q+1])//不匹配时要返回的位置 q=next[q]; if(s[i]==s[q+1])//如果下个字符匹配,那么直接继承之前的已匹配区域. q++; next[i]=q; &#125; return next; &#125;&#125;;int main()&#123; string s1=\"ababcd\"; string needle=\"abc\"; Solution s; cout&lt;&lt;s.strStr(s1,needle)&lt;&lt;endl;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"检查带环链表入口问题","date":"2017-03-24T12:21:11.000Z","path":"2017/03/24/检查带环链表入口问题/","text":"这两天一直在做链表的题目,遇到了一道有环链表的问题,感觉很有趣:题目:给一个链表,如果有回路返回回路开始的节点,没有回路则返回NULL 思路:两个指针一快一慢,fas与slow相遇时,fast已经在圈内循环了n圈,设slow走了n步,则fast走了2s步(fast步数还等于s加上在环上多转的n圈),设环长为r,于是: 2s=s+nr s=nr 设整个链表长L,环入口点与相遇点距离为a,起点到环入口点的距离为x,则: x+a=nr=(n-1)r+r=(n-1)r+L-x x=(n-1)r+(L-x-a) L-x-a为相遇点到环入口点的距离,由此可知,从链表头到环入口点等于n-1圈内环+相遇点到入口点,于是我们可以从head开始另设一个指针slow2,两个慢指针 slow2,两个慢指针每次前进一步,它俩一定会在环入口点相遇*/ 2.2.12.cpp1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;struct ListNode&#123; int val; ListNode* next; ListNode(int x):val(x),next(NULL)&#123;&#125;&#125;;class Solution&#123; ListNode* detectCycle(ListNode* head)&#123; ListNode* slow=head,*fast=head; while(fast&amp;&amp;fast-&gt;next)&#123; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; if(slow==fast)&#123; ListNode* slow2=head; while(slow2!=slow)&#123; slow2=-&gt;slow2-&gt;next; slow=slow-&gt;next; &#125; return slow2; &#125; &#125; return NULL; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"互斥量和避免死锁","date":"2017-03-15T05:17:04.000Z","path":"2017/03/15/互斥量和避免死锁/","text":"互斥量互斥变量是用pthread_mutex_t数据类型表示的,在使用互斥变量之前,必须首先对它进行初始化,可以把它设置为常量PTHREAD_MUTEX_INITIALIZER(只适用于静态分配的互斥量),也可以调用pthread_mutex_init进行初始化,如果动态分配互斥量,在释放内存前需要调用pthread_mutex_destory.1234567#include&lt;pthread.h&gt;int pthread_mutex_init(pthread_mutex_t* restrict mutex, const pthread_mutexattr_t* restrict attr);int pthread_mutex_destory(pthread_mutex_t* mutex);int pthread_mutex_lock(pthread_mutex_t* mutex);int pthread_mutex_trylock(pthread_mutex_t* mutex); //不阻塞,只尝试加锁,若失败返回EBUSY.int pthread_mutex_unlock(pthread_mutex_t* mutex); 死锁如果线程试图对同一个互斥量加锁两次,那么它自身就会陷入死锁状态,但是使用互斥量时,还有其他不太明显的方式也能产生死锁,例如,程序中使用一个以上的互斥量时,如果允许一个线程一直占用第一个互斥量,并且在试图锁住第二个互斥量时处于阻塞状态,但是拥有第二个互斥量的线程也在师徒锁住第一个互斥量.因为两个线程都在相互请求另一个线程拥有的资源,所以这两个线程都无法向前运行,于是就产生死锁.解决办法就是控制互斥量加锁顺序,比如同时要对互斥量A和B加锁,如果所有线程总是在对B加锁前锁住A,那么使用这两个就不会产生死锁.可以参考下面的例子:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;stdlib.h&gt;#include&lt;pthread.h&gt;const int NHASH=29;#define HASH(id) (((unsigned long)id)%NHASH)pthread_mutex_t hashlock=PTHREAD_MUTEX_INITIALIZER;struct foo&#123; int f_count; pthread_mutex_t f_lock; int f_id; struct foo* f_next;//protected by hashlock&#125;;struct foo* fh[NHASH];struct foo* foo_alloc(int id)&#123; struct foo* fp; int idx; if((fp=(struct foo*)malloc(sizeof(struct foo)))!=NULL)&#123; fp-&gt;f_count=1; fp-&gt;f_id=id; if(pthread_mutex_init(&amp;fp-&gt;f_lock,NULL)!=0)&#123; free(fp); return NULL; &#125; idx=HASH(id); pthread_mutex_lock(&amp;hashlock); fp-&gt;f_next=fh[idx]; fh[idx]=fp; pthread_mutex_lock(&amp;fp-&gt;f_lock); pthread_mutex_unlock(&amp;hashlock); &#125; return fp;&#125;void foo_hold(struct foo* fp)&#123; pthread_mutex_lock(&amp;fp-&gt;f_lock); fp-&gt;f_count++; pthread_mutex_unlock(&amp;fp-&gt;f_lock);&#125;struct foo* foo_find(int id)&#123; struct foo* fp; pthread_mutex_lock(&amp;hashlock); for(fp=fh[HASH(id)];fp!=NULL;fp=fp-&gt;f_next)&#123; if(fp-&gt;f_id==id)&#123; fp-&gt;f_count++; break; &#125; &#125; pthread_mutex_unlock(&amp;hashlock); return fp;&#125;//第一个版本的释放函数,严格按照每种互斥量的功能来锁住临界区,由于需要考虑互斥量使用顺序,会导致代码变得复杂.(foo_rele函数中先上锁在观察是否需要修改fh散列表,如果需要修改则必须先解锁在按顺序上锁)void foo_rele(struct foo* fp)&#123; struct foo* tfp; int idx; pthread_mutex_lock(&amp;fp-&gt;f_lock); if(fp-&gt;f_count==1)&#123; pthread_mutex_unlock(&amp;fp-&gt;f_lock); pthread_mutex_lock(&amp;hashlock); pthread_mutex_lock(&amp;fp-&gt;f_lock); if(fp-&gt;f_count!=1)&#123; fp-&gt;f_count--; pthread_mutex_unlock(&amp;fp-&gt;f_lock); pthread_mutex_unlock(&amp;hashlock); return; &#125;else&#123; idx=HASH(fp-&gt;f_id); tfp=fh[idx]; if(tfp==fp)&#123; fh[idx]=fp-&gt;f_next; &#125;else&#123; while(tfp-&gt;f_next!=fp) tfp=tfp-&gt;f_next; tfp-&gt;f_next=fp-&gt;f_next; &#125; &#125; pthread_mutex_unlock(&amp;fp-&gt;f_lock); pthread_mutex_unlock(&amp;hashlock); pthread_mutex_destory(&amp;fp-&gt;f_lock); free(fp); &#125;else&#123; fp-&gt;f_count--; pthread_mutex_unlock(&amp;fp-&gt;f_lock); &#125;&#125;//第二个版本的释放函数.直接用hashlock来锁住对fp的操作,避免了两个互斥量使用的顺序问题.简化了代码.但是线程阻塞的概率会更大,因为hashlock使用的范围更大.需要权衡两者的使用.void foo_rele2(struct foo* fp)&#123; struct foo* tfp; int idx; pthread_mutex_lock(&amp;hashlock); if(--fp-&gt;f_count==0)&#123; idx=HASH(fp-&gt;f_id); tfp=fh[idx]; if(tfp==fp)&#123; fh[idx]=fp-&gt;f_next; &#125;else&#123; while(tfp-&gt;f_next!=fp) tfp=tfp-&gt;f_next; tfp-&gt;f_next=fp-&gt;f_next; &#125; pthread_mutex_unlock(&amp;hashlock); pthread_mutex_destory(&amp;fp-&gt;f_lock); free(fp); &#125;else pthread_mutex_unlock(&amp;hashlock);&#125;","tags":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/tags/apue/"},{"name":"c","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"fork()和vfork()的总结","date":"2017-03-04T07:04:27.000Z","path":"2017/03/04/fork-和vfork-的总结/","text":"fork()函数可以创建一个新的进程,被称为子进程,子进程获得父进程数据空间,堆和栈的副本.父子进程不共享这些存储空间部分,共享正文段. 看下面一个实例:8.3.c/*打印父子进程的输出*/123456789101112131415161718192021#include \"apue.h\" int globvar= 6;char buf[] = \"a write to stdout\\n\"int main()&#123; int var; pid_t pid; var=88; if(write(STDOUT_FILENO,buf,sizeof(buf)-1)!=sizeof(buf)-1) err_sys(\"write error\"); printf(\"before fork\\n\"); if((pid=fork())&lt;0) err_sys(\"fork error\"); else if(pid==0)&#123; globvar++; var++; &#125;else sleep(2); printf(\"pid=%ld,glob=%d,var=%d\\n\",(long)getpid(),globvar,var); exit(0);&#125; 运行后结果:123456$ gcc 8.3.c -o8.3 -lapue$ ./8.3a write to stdoutbefore forkpid=5423,glob=7,var=89pid=5422,glob=6,var=88一切正常运行,但是如果我们重定向标准输出流之后:1234567$ ./8.3 &gt; temp.out$ cat temp.outa write to stdoutbefore forkpid=5481,glob=7,var=89before forkpid=5480,glob=6,var=88 可以看到printf输出了两次,原因是在fork()之前调用了一次printf一次,但当调用fork()时,该行数据还在缓冲区中(因为重定向之后为全缓冲),然后讲父进程数据空间复制到子进程中时,该缓冲区数据也被复制到子进程中,此时父进程和子进程各自有了带该行内容的缓冲区.当进程终止时,缓冲区内容被刷新写到文件中. 子进程和父进程之间的区别如下: fork返回值不同(进程ID不同)子进程不继承父进程设置的文件锁子进程的未处理闹钟被清除.子进程的未处理信号集设置为空集.有时候实际用户ID的进程总数超过了系统限制,会导致fork()失败. vfork()函数用于创建一个新进程,而该进程的目的是exec一个新程序.vfork()不会将父进程的地址空间完全复制到子进程中,另一个区别是,vfork()保证子进程先运行,在它调用exec或exit之后父进程才可能被调度运行,当子进程调用这两个函数中的任意一个时,父进程会恢复运行.(如果在调用这两个函数之前子进程依赖父进程的进一步动作会导致死锁.)引用网上的一个说法:为什么会有vfork，因为以前的fork 很傻， 它创建一个子进程时，将会创建一个新的地址空间，并且拷贝父进程的资源，而往往在子进程中会执行exec 调用，这样，前面的拷贝工作就是白费力气了，这种情况下，聪明的人就想出了vfork，它产生的子进程刚开始暂时与父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中运行，所以子进程不能进行写操作，并且在儿子 霸占”着老子的房子时候，要委屈老子一下了，让他在外面歇着（阻塞），一旦儿子执行了exec 或者exit 后，相 于儿子买了自己的房子了，这时候就相当于分家了。","tags":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/tags/apue/"}]},{"title":"递归降序遍历目录结构","date":"2017-03-03T02:06:09.000Z","path":"2017/03/03/递归降序遍历目录结构/","text":"参考apue第四章代码:4.22.c/*此程序用来递归降序遍历文件层次结构,命令行传入一个参数作为起点路径名.*/123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;errno.h&gt;#include\"apue.h\"#include&lt;limits.h&gt;//定义了数据类型的范围.例如INT_MAX宏为该环境下int类型的最大值.#include&lt;dirent.htypedef int Myfunc(const char*,const struct stat*,int);char* path_alloc(size_t*);static Myfunc myfunc;static int myftw(char*,Myfunc*);static int dopath(Myfunc*);static long nreg,ndir,nblk,nchr,nfifo,nslink,nsock,ntot;int main( int argc,char** argv)&#123; int ret; if(argc!=2) err_quit(\"Usage: ftw &lt;starting-pathname&gt;\"); ret=myftw(argv[1],myfunc); ntot=nreg+ndir+nblk+nchr+nfifo+nslink+nsock; if(ntot==0) ntot=1; printf(\"regular files= %7ld,%5.12f %%\\n\",nreg,nreg*100.0/ntot); printf(\"directories = %7ld,%5.12f %%\\n\",ndir,ndir*100.0/ntot); printf(\"block special = %7ld,%5.12f %%\\n\",nblk,nblk*100.0/ntot); printf(\"char special = %7ld,%5.12f %%\\n\",nchr,nchr*100.0/ntot); printf(\"FIFOS = %7ld,%5.12f %%\\n\",nfifo,nfifo*100.0/ntot); printf(\"symbolic links = %7ld,%5.12f %%\\n\",nslink,nslink*100.0/ntot); printf(\"sockets = %7ld,%5.12f %%\\n\",nsock,nsock*100.0/ntot); exit(ret);&#125;/*文件名路径分配函数#ifdef PATH_MAXstatic long pathmax = PATH_MAX;#elsestatic long pathmax = 0;#endifstatic long posix_version = 0;static long xsi_version = 0;/* If PATH_MAX is indeterminate, no guarantee this is adequate */#define PATH_MAX_GUESS 1024char *path_alloc(size_t *sizep) /* also return allocated size, if nonnull */&#123; char *ptr; size_t size; if (posix_version == 0) posix_version = sysconf(_SC_VERSION); if (xsi_version == 0) xsi_version = sysconf(_SC_XOPEN_VERSION); if (pathmax == 0) &#123; /* first time through */ errno = 0; if ((pathmax = pathconf(\"/\", _PC_PATH_MAX)) &lt; 0) &#123; if (errno == 0) pathmax = PATH_MAX_GUESS; /* it's indeterminate */ else err_sys(\"pathconf error for _PC_PATH_MAX\"); &#125; else &#123; pathmax++; /* add one since it's relative to root */ &#125; &#125; /* * Before POSIX.1-2001, we aren't guaranteed that PATH_MAX includes * the terminating null byte. Same goes for XPG3. */ if ((posix_version &lt; 200112L) &amp;&amp; (xsi_version &lt; 4)) size = pathmax + 1; else size = pathmax; if ((ptr = malloc(size)) == NULL) err_sys(\"malloc error for pathname\"); if (sizep != NULL) *sizep = size; return(ptr);&#125;#define FTW_F 1#define FTW_D 2#define FTW_DNR 3#define FTW_NS 4static char* fullpath;static size_t pathlen;static int myftw(char* pathname,Myfunc* func)&#123; fullpath=path_alloc(&amp;pathlen); if(pathlen&lt;=strlen(pathname))&#123; pathlen=strlen(pathname)*2; if((fullpath=realloc(fullpath,pathlen))==NULL) err_sys(\"realloc failed\"); &#125; strcpy(fullpath,pathname); return dopath(func);&#125;/*用来递归调用myfunc来处理路径内的每个文件.static int dopath(Myfunc* func)&#123; struct stat statbuf; struct dirent* dirp; DIR* dp; int ret,n; if(lstat(fullpath,&amp;statbuf)&lt;0) return func(fullpath,&amp;statbuf,FTW_NS); if(S_ISDIR(statbuf.st_mode)==0) return(func(fullpath,&amp;statbuf,FTW_F)); if(ret=func(fullpath,&amp;statbuf,FTW_D)!=0) return ret; n=strlen(fullpath); if(n+NAME_MAX+2&gt;pathlen)&#123; pathlen*=2; if((fullpath=realloc(fullpath,pathlen))==NULL) err_sys(\"realloc failed\"); &#125; fullpath[n++]='/'; fullpath[n]=0; if((dp=opendir(fullpath))==NULL) return func(fullpath,&amp;statbuf,FTW_DNR); while((dirp=readdir(dp))!=NULL)&#123; if(strcmp(dirp-&gt;d_name,\".\")==0||strcmp(dirp-&gt;d_name,\"..\")==0) continue; strcpy(&amp;fullpath[n],dirp-&gt;d_name); if((ret=dopath(func))!=0) break; &#125; fullpath[n-1]=0; closedir(dp); return ret;&#125;/*用来判断输入路径的文件类型,也可能是目录文件*/static int myfunc(const char* pathname,const struct stat* statptr,int type)&#123; switch(type)&#123; case FTW_F: if(S_ISREG(statptr-&gt;st_mode)) nreg++; if(S_ISBLK(statptr-&gt;st_mode)) ndir++; if(S_ISCHR(statptr-&gt;st_mode)) nchr++; if(S_ISFIFO(statptr-&gt;st_mode)) nfifo++; if(S_ISLNK(statptr-&gt;st_mode)) nslink++; if(S_ISSOCK(statptr-&gt;st_mode)) nsock++; break; case FTW_D: ndir++; break; case FTW_DNR: err_ret(\"Can't read directory %s\",pathname); break; case FTW_NS: err_ret(\"stat error for %s\",pathname); break; &#125; return 0;&#125; 运行结果如下:12345678$ /home/wangliang/apue/4.22 /regular files= 389832,70.403768044225 %directories = 61804,11.161819656173 %block special = 0,0.000000000000 %char special = 230,0.041538064218 %FIFOS = 6,0.001083601675 %symbolic links = 101781,18.381677018073 %sockets = 56,0.010113615636 %","tags":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/tags/apue/"}]},{"title":"typedef总结","date":"2017-03-02T02:23:58.000Z","path":"2017/03/02/typedef总结/","text":"今天在apue上看到如下定义:4.22.c12typedef int Myfunc(const char*,const struct stat*,int);static Myfunc myfunc;于是翻了一下c primer 复习了一下typedef的用法:1.自定义变量别名. 2.自定义结构体名称1234typedef struct &#123; float real; float imag;&#125;COMPLEX;3.定义复杂类型:1typedef char(* FRPTC())[5];这句话把frptc声明为一个函数类型,该函数返回一个指向5个元素的char数组的指针.对复杂变量的声明,只要记住在传统声明定义表达式里用类型名代替变量名,然后在开头加上typedef.对于理解复杂声明声明可用的“右左法则”：从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：int (func[5])(int );func右边是一个[]运算符，说明func是具有5个元素的数组；func的左边有一个，说明func的元素是指针（注意这里的不是修饰func，而是修饰func[5]的，原因是[]运算符优先级比高，func先跟[]结合）。跳出这个括号，看右边，又遇到圆括号，说明func数组的元素是函数类型的指针，它指向的函数具有int类型的形参，返回值类型为int。","tags":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/tags/apue/"},{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"apue学习笔记1-exec函数总结","date":"2017-02-27T07:46:57.000Z","path":"2017/02/27/apue学习笔记1-exec函数总结/","text":"这学期开始看apue第三版,并记录相关知识点的笔记.首先复习exec函数的使用. exec函数总共有七个:123456789#include&lt;unistd.h&gt;int execl(const char* pathname,const char* arg0,.../*(char* )0 */);int execv(const char* pathname,char* const argv[]);int execle(const char* pathname,const char* arg0,... /* (char*)0,char* const envp[]*/);int execve(const char* pathname,char* const argv[],char* const envp[]);int execlp(const char* filename,const char* arg0,.../*(char*)0 */);int execvp(const char* filename,char* const argv[]);int fexecve(int fd,char* const argv[],char *const envp[]); 函数之间第一个区别在前4个取路径做参数,后两个函数取文件名做参数,最后一个取文件描述符.也就是说后两个函数可以从环境变量PATH中寻找.第二个区别与参数表有关,以const char* arg0,arg1…传入的为参数列表,需要以空指针做结尾第三个区别环境变量：exec函数族使用了系统默认的环境变量，也可以传入指定的环境变量。这里以“e”（environment）结尾的两个函数execle、execve就可以在envp[]中指定当前进程所使用的环境变量替换掉该进程继承的所以环境变量。这七个只有execve是内核的系统调用,其他的都是库函数.上代码实例:exec.c/*echoall程序用来打印命令行参数和环境表 */123456789101112131415161718#include\"apue.h\"#include&lt;unistd.h&gt;int main(int argc,char** argv)&#123; pid_t pid; char** env_init=&#123;\"USER=unknown\",\"PATH=/tmp\",NULL&#125;; if((pid=fork())&lt;0)&#123; err_sys(\"fork error\"); &#125;else if(pid==0)&#123; if(execle(\"/home/wangliang/bin/echoall\",\"echoall\",\"myarg1\",\"MY ARG2\",(char*)0,env_init)&lt;0) err_sys(\"execle error\"); &#125; if(waitpid(pid,NULL,0)&lt;0) error_sys(\"wait error\"); if((pid=fork)==0) if(execlp(\"echoall\",\"echoall\",\"only 1arg\",(char*)0)&lt;0) err_sys(\"execlp() error\"); exit(0);&#125;","tags":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/tags/apue/"}]},{"title":"利用hexo和githubpage搭建个人博客","date":"2017-02-26T13:03:23.000Z","path":"2017/02/26/利用hexo和github-page-搭建个人博客/","text":"最近博主花了几天的时间终于搭建好了自己的小窝,也是在入坑爬坑的过程弄出来了,参照网上的一些资料教程,自己总结的一套方法如下: 安装node.js Node.js是一个开放源代码、跨平台的、可用于服务器端和网络应用的运行环境，该应用由 C++ 语言写成，在 Node.js 运行时运行。Node.js 提供事件驱动和非阻塞 I/O API，可优化应用程序的吞吐量和规模。这些技术通常被用于实时应用程序。并且它是采用 Google 的 V8 引擎来执行代码，它的大部分基本模块都是用 JavaScript 写成的，包含有一系列内置模块，使得程序可以作为独立服务器运行，从而脱离 Apache HTTP Server 或 IIS 运行。而 npm 也即 Node包管理器（Node Package Manager），它是一个以 Javascript 编写的软件包管理系统，默认环境为 Node.js 。 所以首先得安装node.js和npm,命令如下:12$ sudo apt-get install nodejs$ sudo apt-get install npm或者从官网上下载对应平台的版本进行安装.可以用命令node -v如果出现版本号则安装成功.接下来安装nrm,是npm的资源管理器:1$ sudo npm install nrm -g --registry https://registry.npm.taobao.org接下来设置下载源为淘宝源(防止默认下载源速度慢超时):1$ nrm use taobao可能出现命令未识别,则说明没有全局安装,这时候需要你用ln命令将你下载的可执行文件链接到usr/local/bin/目录下.(如果正常则跳过)1$ ln -s &lt;下载文件&gt; usr/local/bin/&lt;文件名&gt;接下来需要下载hexo,可用如下命令(记住加上-g进行全局安装):1$ sudo npm install hexo -g 安装git工具然后需要安装git工具,需要了解git和如何使用的话可以查阅 git安装教程 搭建博客接下来开始搭建,在自己的主目录下创建Blog目录并生成初始框架:1234$ mkdir Blog &amp;&amp; cd Blog$ hexo init$ hexo generate$ hexo server打开浏览器输入localhost:4000可看到已经生成的初始界面.因为通过hexo server已经运行了本地的服务器进入目录 /home/shiyanlou/Code/Hexo/blog/themes ，下载并解压缩 Next 主题。12$ wget http://labfile.oss.aliyuncs.com/courses/700/next.zip$ unzip next.zip编辑 ~/Blog/config.yml文件,修改主题那一行theme: next(记住选项冒号之后都有空格)可以自行修改其他信息,每次修改后都要执行hexo clean和hexo g命令,关于如何使用hexo和添加自己的文章,修改样式等请参阅: hexo中文官网教程 部署到github如上操作完只是在本地生成了你的静态主页,我们需要传到github仓库里这样别人访问你的仓库就可以自动展示你的博客.首先打开你的github创建一个新的仓库,仓库名格式为:你的git账户名.github.io.如下图:进入Blog目录下,同步你的仓库:1$ git clone [你的仓库的url] 仓库url可以在下图获得:一路顺利后,打开 Blog目录下的config.yml文件,在最下面修改:1234deploy: type: git respository: https://github.com/[你的github用户名]/[你的github用户名].github.io.git branch: master再执行命令:12$ npm install hexo-deployer-git --save$ hexo d然后在浏览器浏览http://[你的github用户名]/github.io至此,初步的搭建已经完成,接下来就是参阅markdown语法和hexo教程来多写文章吧.","tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}]}]