[{"title":"仿c语言自制编程语言笔记5","date":"2018-01-30T05:25:25.000Z","path":"2018/01/30/仿c语言自制编程语言笔记5/","text":"中间代码的转换中间代码的目的主要有两个: 让抽象语法树的代码转成更接近机器语言的代码.直接编写从抽象语法树到汇编语言的代码比较困难. 保留一些进一步优化的意图.比如说两条语句n=n*1;n*=1;这两条语句都属于赋值类型,都不改变n的值,如果要删去的话属于两类节点Opassignnode,BinaryOpNode,优化代码会重复出现.还有ifelseswitchwhile这些跳转语句,尽量翻译成接近汇编指令的形式,改成一系列的代码和jump. 按照语法树的结构遍历树,生成中间代码,因此生成的中间代码本身还是树型,中间代码是单纯的语句列表,列表由一系列表达式组成.和抽象语法树的节点结构一样,组成中间代码的节点结构也是继承关系,如下所示:123456789101112131415161718IR //中间代码的根节点Stmt //基类 Assign //赋值 CJump //跳转 Jump //无条件跳转 Switch //多分支跳转 LabelStmt //标签 ExprStmt //仅包含一个表达式的语句 Return //返回语句Expr //基类 UnaryOp //一元运算 BinaryOp //二元运算 Call //函数调用 Addr //取地址 Mem //取值 Var //变量 Int //整数常量 Str //字符串常量 相比于语法树中的表达式节点,这里的表达式的类型直接定义在基类中,为asm中定义的type,而不是语法树中定义的type,asm中定义的type只含有定义不同字节长度INT类型.除此之外还要制定运算符op的类型,用一个枚举类型定义各种运算符的名称.而且运算符的定义有有无符号的区分,这样asm.Type中的类型就不需要符号.类型中的代码基本都和翻译对应的语法树节点代码相符. IRGenerator和语义分析的几个类的结构一样,都是对抽象语法树进行遍历,但是每个对表达式的visit方法返回的不是空,而是一个中间代码的表达式节点对象.而且这个对象要保存到对应的抽象语法树的节点上.对stmtnode的处理不返回新生成的节点,而是用一个列表来保存每条转换后的stmt.完毕后才保存到对应的函数节点上.总的启动入口:1234567891011121314public IR generate(AST ast)&#123; for(DefinedVariable var:ast.definedVariables())&#123; if(var.hasInitializer())&#123; var.setIR(transformExpr(var.initializer())); &#125; &#125; for(DefinedFunction func:ast.definedFunctions())&#123; func.setIR(compileFunctionBody(func)); &#125; if(errorHandler.errorOccured())&#123; throw new SemanticException(\"IR generation failed\"); &#125;return new IR(ast.location(),ast. &#125; 删除了分开解析表达式是否需要返回值的功能. 流程控制跳转语句解析break和continue时,需要一个栈来存放当前对应跳转的Label,还需要一个栈来保存作用域生成临时变量时可以使用.对于if的解析,解析可分为有条件跳转,无条件跳转,跳转标签组成.在需要添加label的地方在stmt列表中按顺序添加一个LabelStmt对象,当做跳转目标用来控循环等.对于switch,while,for等跳转语句实现原理类似. 没有副作用的表达式转换主要是二元运算符的表达式转换.首先转换左右表达式和操作符,先处理右侧表达式,因为有可能表达式会改变某些值,比如右侧有i++这种,左侧也有i这个值,那么处理左侧时i的值就会被+1,还要处理指针之间的运算:12345678910111213141516171819202122232425262728public Expr visit(BinaryOpNode node) &#123; Expr right = transformExpr(node.right()); Expr left = transformExpr(node.left()); Op op = Op.internBinary(node.operator(), node.type().isSigned()); type.Type t = node.type(); type.Type r = node.right().type(); type.Type l = node.left().type(); //指针类型间的运算 if (isPointerMinus(op, l, r)) &#123; //指针相减的情况,添加一个除法,除去基本类型的大小. Expr tmp = new BinaryOp(asmType(t), op, left, right); return new BinaryOp(asmType(t), Op.S_DIV, tmp, ptrBaseSize(l)); &#125; else if (isPointerAddNum(l,op,r)) &#123; // 指针加上一个整数的情况,要乘上基本类型的大小. return new BinaryOp(asmType(t), op, left,new BinaryOp(asmType(r), Op.MUL, right, ptrBaseSize(l))); &#125; else if (isNumAddPointer(l,op,r)) &#123; //同上 return new BinaryOp(asmType(t), op, new BinaryOp(asmType(l), Op.MUL, left, ptrBaseSize(r)), right); &#125; else &#123; return new BinaryOp(asmType(t), op, left, right); &#125;&#125; 有副作用的表达式转换副作用是指执行表达式时,表达式除返回值之外产生的影响,比如赋值语句会导致内存中的某个值发生了变化,比如一个函数的调用也会改变内存中某些值,也存在副作用.有副作用会导致语句的执行顺序会对结果产生影响,不利于程序的优化.如何转化带副作用的表达式: 要严格保证一条语句中副作用部分和其他部分发生的顺序不变,这样生成的中间代码也按顺序排列. 有副作用的情况分为赋值和函数调用. 有副作用的表达式如果含有函数调用,那么就会多出一个表达式,visit方法只能返回一个Expr,需要向stmts列表中添加. 要灵活运用临时变量,对于有递归的表达式,先生成一个临时变量来保存子表达式的值,然后返回给上一层表达式.什么是左值?比如一个语句int i=0;i++=i;这样编译不合法,因为赋值左边的(expr)++拆成了三个部分,int tmp=i;i=i+1; return tmp;返回的是一个临时局部变量,不是一个左值.因此int i=0;i=i++;这样的语句i的值还是0.左值转换C–中左值包括: 变量,节点为VariableNode 指针取值,节点为DereferenceNode 数组,节点为ArefNode 结构体和联合体的成员,节点为PtrMemberNode,MemberNode如果一个变量写在左边那么需要转换成这个变量的地址的代码,如果写在右边,那么就转换成获取变量的值的代码.变量的节点作为左值的话直接可以转成Addr中间节点,右值的话直接转成Var中间节点.具体对应的方法是visit到MemberNode,或者二元运算节点,转化为一个Derefer解引用节点,其中保存了一个解引用的地址. 结构体成员的偏移,要考虑字节对齐.字节对齐的调用主要通过计算每个成员的偏移量,这样在结构体调用成员时直接转成对应的地址,然后再加上一个Mem节点,既可以成为右值,也可以成为左值.代码中需要频繁用到左值和右值的情况,为了方便,将表达式先转成解引用节点或者Var节点,这些都是右值,写一个addressOf方法专门用来将右值转左值.","tags":[{"name":"JAVASE","slug":"JAVASE","permalink":"http://yoursite.com/tags/JAVASE/"},{"name":"编译器","slug":"编译器","permalink":"http://yoursite.com/tags/编译器/"},{"name":"C--","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"仿c语言自制编程语言笔记4","date":"2018-01-23T02:09:56.000Z","path":"2018/01/23/仿c语言自制编程语言笔记4/","text":"语义分析语义分析是对生成的抽象语法树的语义进行分析,并且实施变量引用的消解和类型检查.有如下几个处理: 变量引用的消解 确定具体指向哪个变量.比如有全局变量i,有局部变量i,通过作用域来消除. 类型名称的消解 TypeRef表示类型的名称,要转化为Type. 类型定义的检查 检查语义问题,比如void数组不合法,结构体含有自身类型的成员不合法等. 表达式的有效性检查 检查表达式是否可以执行. 静态类型检查 检查类型是否正确.上述执行的顺序是1-&gt;4,2-&gt;3-&gt;4,4-&gt;5. 一颗语法树的结构大致如下:1234567= * * * * * +i * * * * 1 3 我们作上述的检查需要对整个树进行遍历,而且是需要先遍历左右子树然后再到父节点,是一个后序遍历.我们可以在每个节点的–类中实现一个check方法,方法中调用自己所含的节点check方法.为了将代码能够整合到一起,可以用vsitior模式,编写一个专门用来check的类,然后在每个类中调用这个类中的方法.考虑到每种消解都要进行遍历,因此一个节点如果对每种消解方法都要写一个调用,会导致成倍的增加,因此我们把所有消解方法抽象出一个接口,然后每个类中的accept方法接受这个接口.比如说,对于节点的visit接口:123456789101112public interface ASTVisitor &#123; //语句的接口 public void visit(BlockNode node); public void visit(ExprStmtNode node); //... // 表达式的visit接口 public void visit(AssignNode node); public void visit(OpAssignNode node); public void visit(CondExprNode node); //...&#125; 这样对于语义分析中的类型检查,我们就可以让它实现这个接口,这样在每个节点类里只要有一个参数是这个接口的visitor方法就可以:1234567891011121314151617TypeChecker implements ASTVisitor&#123; void visit(BlockNode node)&#123; for(StmtNode sn:node.stmts())&#123; sn.accept(this); &#125; for(Entity en:node.entity())&#123; en.accept(this); &#125;//每个节点类中Class Node&#123;public abstract void accept(ASTVisitor visitor);&#125;Class AST extends Node&#123; public void accept(ASTVisitor visitor)&#123; visitor.visit(this); &#125;&#125; 有三个接口,分别是: ASTVisitor 语句和表达式的节点遍历 EntityVisitor 给实体类型遍历 DeclarationVisitor 给声明的类型节点遍历 变量引用的消解当变量名有冲突时,我们要考虑变量i是全局变量i还是局部变量i,对生成的抽象语法树中的VariableNode节点添加该变量的定义的信息,也就是Variable对象.将整个作用域分成两块: Scope 表示作用域的抽象类 ToplevelScope 表示程序顶层的作用域.保存有函数和全局变量. LocalScope 表示一个临时变量的作用域,保存形参和临时变量. 我们作用域可形成一颗树,根节点是全局作用域,其中包含着若干局部作用域,每个局部又包含局部,这样把整个域划分好:123456ToplevelScope* * * * LocalScope LocalScope * * * * * * 我们查找一个变量的定义,只要从引用了该变量的作用域往上查找到第一个变量定义即为其定义.用来做变量引用消解的类为LocalResolver,也是实现了ASTVisitor接口,该类利用栈来一边生成Scope对象的树一遍进行变量引用的消解.每次将当前作用域的符号表也就是LocalScope对象,push到栈内,对一个变量查找其定义时,从栈顶开始查找,这样能一边给变量添加定义,也能生成Scope树. Scope类123public abstract class Scope &#123; protected List&lt;LocalScope&gt; children;&#125; 主要就是包含若干子作用域. ToplevelScope类123public class ToplevelScope extends Scope&#123; Map&lt;String, Entity&gt;entities;&#125; LocalScope类1234public class LocalScope extends Scope&#123; private Scope parent; private Map&lt;String, DefinedVariable&gt;variables;&#125; 包含了一个保存当前作用域内定义的变量或者函数,称之为符号表.局部作用域还保存了父作用域. LocalResolver通过之前编写的visitor模式,对于我们想要实现的操作,我们只要在类中实现具体的visit方法即可,不用管如何在节点中遍历的.先看含有的成员:123456public class LocalResolver extends Visitor&#123; private LinkedList&lt;Scope&gt;scopeStack;//用来处理的栈 private ConstantTable constantTable//用来管理字符串常量的表 private ErrorHandler errorHandler; ...&#125; 其中栈通过pushScope操作来完成,对于变量节点VariableNode的处理,都是在当前栈顶的作用域或向上查找定义.下面是总的调用,我们先导入所有全局变量的定义,因此不需要像c语言一样考虑全局变量或函数定义和使用的先后顺序:12345678910111213141516171819public void resolve(AST ast)&#123; ToplevelScope scope=new ToplevelScope(); scopeStack.push(scope); //首先添加全局声明 for(Entity entity:ast.declarations() )&#123; scope.declareEntity(entity); &#125; //添加全局定义 for(Entity entity :ast.definitions())&#123; scope.defineEntity(entity); &#125; resolveConstantValues(ast.constants()); resolveFunctions(ast.definedFunctions()); resolveDefinedGvars(ast.definedVariables()); scope.checkReference(errorHandler); //保存信息 ast.setScope(scope); ast.setConstantTable(constantTable); &#125; 最后实现具体的三个visit:1234567891011public Void visit(VariableNode node)&#123; String varName=node.name(); Entity ent=currentScope().get(varName);//得到定义 ent.refered(); node.setEntity(ent);//建立联系 &#125; public Void visit(StringLiteralNode node)&#123; String name=node.value(); node.setEntry(constantTable.insert(name)); return null; &#125; 下面是作用域入栈和出栈的方法,由于形参的元素parameter是继承自DefinedVariable,因此需要向下兼容.12345678910111213141516public void pushScope(List&lt;? extends DefinedVariable&gt; vars)&#123; LocalScope scope = new LocalScope(currentScope()); for (DefinedVariable var : vars) &#123; if (scope.hasDefinedVariable(var.name())) &#123; error(var.location(), \"duplicated variable in scope: \" + var.name()); &#125; else &#123; scope.defineVariable(var); &#125; &#125; scopeStack.addLast(scope); &#125; public Scope popScope()&#123; return scopeStack.pop(); &#125; 类型名称的消解目的在于将TypeRef转换Type,我们用TypeResolver类来处理,功能仅仅是遍历抽象语法树,遇到TypeRef类就从叶子节点开始转换为Type类型.没有作用域的限制.TypeRef和Type的对应关系保存在TypeTable中.TypeResolver需要一张类型表和一个错误处理的类,类型表在我们遍历语法树的同时向其中添加类型定义.变量的类型有两种一种定义的一种是声明的,定义的变量又分是否有初始化的. TypeResolver12345678910111213141516public class TypeResolver extends Visitor implements DeclarationVisitor&lt;Void&gt;,EntityVisitor&lt;Void&gt;&#123; TypeTable typeTable; ErrorHandler errorHandler; public void resolve(AST ast)&#123; defineTypes(ast.types()); for(TypeDefinition t:ast.types())&#123; t.accept(this); &#125; for(Entity ent:ast.entities())&#123; ent.accept(this); &#125; &#125; ...&#125;用来消解的方法首先对全局定义的结构体,联合体,还有类型别名这些类型添加到表中,这样接下来遇到typeRef类型就从表中查找其对应的Type,然后绑定到节点的TypeNode上.(这也是为什么TypeNode有两个成员Type和TypeRef) TypeTable关键代码:1234567891011121314public class TypeTable &#123; private int intSize; private int longSize; private int pointerSize;//规定的指针所占字节 Map&lt;TypeRef,Type&gt;table; &#123;...&#125;//一段静态代码用来添加表中基本类型 public TypeTable(int intSize,int longSize,int pointerSize)&#123; this.intSize = intSize; this.longSize = longSize; this.pointerSize = pointerSize; table=new HashMap&lt;TypeRef,Type&gt;(); &#125; ...&#125; 我们的table其实就是一个类型名称和其对应类型的map,在遇到定义的类型时,我们向表中添加自己定义的类型元素. 类型定义检查主要检查三个问题: 包含void数组,结构体,联合体不合法. 成员重复的结构体联合体. 循环定义的结构体,联合体.第三个问题的解决可以转成图的有环问题:123456789101112131415161718192021222324252627282930313233343536/* * 检查是否有循环定义: * 结构体a中含有结构体b,b中含c,c中含a * 转换成一个有向图中检查是否有环的问题. * 可以用DFS,也可以用拓扑排序,后者需要得到图的所有节点,前者可以查看以某一个节点为起点来检查 */ //**************DFS实现*************** public void checkRecursiveDefinition(Type t,ErrorHandler errorHandler)&#123; HashSet&lt;Type&gt;visited=new HashSet&lt;Type&gt;(); _checkRecursiveDefinition( t, errorHandler,visited); &#125; public void _checkRecursiveDefinition(Type t,ErrorHandler errorHandler,HashSet&lt;Type&gt; visited)&#123; if(visited.contains(t))&#123; errorHandler.error(((NamedType)t).location(),\"recursive Type Definition: \"+t); &#125;else&#123; visited.add(t); //复合类型检查所有成员 if(t instanceof CompositeType)&#123; CompositeType tmp=(CompositeType)t; for(Type memberType:tmp.memberTypes())&#123; _checkRecursiveDefinition( memberType, errorHandler,visited); &#125; &#125; //类型别名指向的类型 if(t instanceof UserType)&#123; _checkRecursiveDefinition( ((UserType)t).realType(), errorHandler,visited); &#125; //数组的基本类型也在图中 if(t instanceof ArrayType)&#123; ArrayType tmp=(ArrayType)t; _checkRecursiveDefinition( tmp.baseType(), errorHandler,visited); &#125; visited.remove(t); &#125; &#125; 表达式有效性主要解决表达式不正确的情况,有如下几种: 无法赋值的表达式被赋值 1=2 非法的数组引用 “ab”[1] 非法的函数调用 “string”(a) 非法的成员调用 1.member 操作数非法的指针间接引用(1-&gt;memb) 非指针对象取值 *1 非左值表达式取地址 &amp;func(a) 检查的方法主要分成两类,第一,检查表达式是否可以被赋值,第二,检查操作数的类型是否符合.CorrectExprChecker类1234567891011121314public class CorrectExprChecker extends Visitor&#123; private TypeTable table;//用来生成指针类型(指定指针大小) private ErrorHandler errorHandler;//错误处理 public CorrectExprChecker(TypeTable table,ErrorHandler errorHandler)&#123; this.table=table; this.errorHandler=errorHandler; &#125; public void check(AST ast)throws SemanticException&#123; checkGlobalVariables(ast.definedVariables()); checkfunctions(ast.definedFunctions()); if (errorHandler.errorOccured()) &#123; throw new SemanticException(\"compile failed.\"); &#125;&#125; 关键调用为check,首先处理全局变量中的初始化的表达式,然后处理定义的函数内部的表达式的正确性. 静态类型检查负责检查操作数的类型限制.比如乘法和加法左右必须都是整数,参数为int类型的函数不能传入其他类型的实参.个人不喜欢编译器自动隐式转换,如果需要隐式转换则对于需要转换的节点改成CastNode节点,并附上要转换的类型即可,不实现此功能.首先是启动方法,检查变量:1234567public void check(AST ast)&#123; checkVariables(ast.definedVariables()); checkFunctions(ast.definedFunctions()); if(errorHandler.errorOccured()) &#123; throw new SemanticException(\"compile failed.\"); &#125; &#125; 对于运算符两侧含有short和char类型,需要向上转换到signed int,这属于整型提升.123456789101112private Type integralPromotion(Type t) &#123; if (!t.isInteger()) &#123; throw new Error(\"integralPromotion for \" + t); &#125; Type intType = typeTable.signedInt(); if (t.size() &lt; intType.size()) &#123; return intType; &#125; else &#123; return t; &#125; &#125; 在函数类型中,规定禁止结构体或者联合体称为函数参数类型并且不能赋值.在这一步加了一个boolean类型,对于条件表达式的返回类型,暂且归到整型中,添加了boolean关键字,转换为一个0或者1的字符字面量.占一个字节","tags":[{"name":"JAVASE","slug":"JAVASE","permalink":"http://yoursite.com/tags/JAVASE/"},{"name":"编译器","slug":"编译器","permalink":"http://yoursite.com/tags/编译器/"},{"name":"C--","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"仿c语言自制编程语言笔记3","date":"2018-01-14T13:21:49.000Z","path":"2018/01/14/仿c语言自制编程语言笔记3/","text":"CflatToken这个类是对Token类的一个包装.这样能整合Token和SpecialToken.首先我们看一下官方的Token的定义,这里有两个关键的调用12345//这个方法返回这个token的下一个非特殊token,而且是相连的,如果当前token是一个Specialtoken,则返回下一个Specialtoken. public Token next();//这个方法返回上上一段连续Specialtoken的最后一个,如果要找到第一个,一直调用直到这个方法返回null, public Token specialToken(); 因此,我们可以用这两个方法来分别获得sptoken和普通token.所以在CflatToken类中,实现的方法:123456789101112131415161718192021222324//包括去除头字符的版本,考虑其作用protected List&lt;CflatToken&gt; buildTokenList(Token first, boolean rejectFirstSpecials) &#123; List&lt;CflatToken&gt; result = new ArrayList&lt;CflatToken&gt;(); boolean rejectSpecials = rejectFirstSpecials; for (Token t = first; t != null; t = t.next) &#123; if (t.specialToken != null &amp;&amp; !rejectSpecials) &#123; Token s = specialTokenHead(t.specialToken); for (; s != null; s = s.next) &#123; result.add(new CflatToken(s)); &#125; &#125; result.add(new CflatToken(t)); rejectSpecials = false; &#125; return result; &#125;//得到一段sptoken的第一个 protected Token specialTokenHead(Token firstSpecial) &#123; Token s = firstSpecial; while (s.specialToken != null) &#123; s = s.specialToken; &#125; return s; &#125; 其中token序列相当于链表,每找到一个普通TOKEN,向上遍历找之前的spTOKEN序列的头.然后看情况是否添加. 节点编写首先,我们定义所有的实体类有如下几种: Constant 常量 DefinedVariable 定义的变量 UndefinedVariable 声明的变量 DefinedFunction 定义的函数 UndefinedFunction 声明的函数 StructNode struct定义 UnionNode union定义 TypedefNode 定义的类型看一下我们顶层的Declarations类,这个类在根节点中出现用来汇集import声明和函数体的类.基本上就是一个各种类型的集合.1234567891011public class Declarations &#123; Set&lt;DefinedVariable&gt; defvars = new HashSet&lt;DefinedVariable&gt;(); Set&lt;UndefinedVariable&gt; vardecls = new HashSet&lt;UndefinedVariable&gt;(); Set&lt;DefinedFunction&gt; defuns = new HashSet&lt;DefinedFunction&gt;(); Set&lt;UndefinedFunction&gt; funcdecls = new HashSet&lt;UndefinedFunction&gt;(); Set&lt;Constant&gt; constants = new HashSet&lt;Constant&gt;(); Set&lt;StructNode&gt; defstructs = new HashSet&lt;StructNode&gt;(); Set&lt;UnionNode&gt; defunions = new HashSet&lt;UnionNode&gt;(); Set&lt;TypedefNode&gt; typedefs = new HashSet&lt;TypedefNode&gt;(); //...一些add接口&#125; 接下来抽象出我们的节点的基类node:1234567891011121314151617181920abstract public class Node implements Dumpable &#123; public Node()&#123; &#125; //返回某节点对应的语法在代码中的位置,也能返回出错的语句的位置. abstract public Location location(); public void dump()&#123; dump(System.out); &#125; public void dump(PrintStream out)&#123; dump(new Dumper(out)); &#125; //以文本形式打印语法树 public void dump(Dumper d)&#123; d.printClass(this,location()); _dump(d); &#125; //用来测试 abstract protected void PrintTree(Dumper d);&#125; Node中没有实质内容.PrintTree方法是用来递归打印整个节点向下包含的内容结构.就是一颗抽象语法树子树. 所有的节点类型中包含了type()和origType(),type()返回这个节点包含的整体类型,而后者返回他的基础类型,比如char[]数组返回的类型就是数组,基础类型就是char.type包里定义了一些类型类,比如说我们的指针类PointerType,char,int这些都属于这个类,因此应该包含一个保存基础类型的成员.在设计type系列的类时候,要考虑如下几个方面: 类型的类要考虑能否转换.比如int可以转换成一个指针类型 考虑是不是同一种类型. 考虑两个类型是不是兼容,比如int可以兼容void. 复合类型需要基础类型. 从实体中可以抽象出他的类型,比如从一个Definedfunction中抽出他的参数列表类型,返回值类型. 解析器的启动模块在Parser这个类里,首先编写构造函数:123456789101112public parser(Reader s,String filename,LibraryLoader loader,ErrorHandler errorHandler,boolean debug) &#123; this(s);//调用默认的构造函数 this.loader=loader;//加载器加载import的文件 this.errorHandler=errorHandler;//错误处理的对象 this.sourceName=filename;//解析的当前文件名 this.knownTypedefs=new HashSet&lt;String &gt;(); if(debug) &#123; enable_tracing();//启动跟踪功能 &#125;else &#123; disable_tracing(); &#125; &#125; 构造函数中用Javacc默认的第三个构造函数,debug用来开启javacc的调试模式.我们需要一个能解析源文件的方法和一个解析头文件的方法:123456789101112131415161718192021222324252627//用来解析当前内文件是源文件的调用,返回一个AST对象 public AST parse() throws SyntaxException &#123; try &#123; return compilation_unit(); &#125; catch (TokenMgrError err) &#123; throw new SyntaxException(err.getMessage()); &#125; catch (ParseException ex) &#123; throw new SyntaxException(ex.getMessage()); &#125; catch (LookaheadSuccess err) &#123; throw new SyntaxException(\"syntax error\"); &#125; &#125;//用来解析当前文件为声明文件的调用,返回一个Declarations对象 public Declarations parseDecls() throws SyntaxException &#123; try &#123; return declaration_file(); &#125; catch (TokenMgrError ex) &#123; throw new SyntaxException(ex.getMessage()); &#125; catch (ParseException ex) &#123; throw new SyntaxException(ex.getMessage()); &#125; &#125;","tags":[{"name":"JAVASE","slug":"JAVASE","permalink":"http://yoursite.com/tags/JAVASE/"},{"name":"编译器","slug":"编译器","permalink":"http://yoursite.com/tags/编译器/"},{"name":"C--","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"仿c语言自制编程语言笔记2","date":"2018-01-14T13:18:07.000Z","path":"2018/01/14/仿c语言自制编程语言笔记2/","text":"草,上周的词法分析,语句分析的笔记忘记保存没了…. 表达式分析javaCC将一个规则转化为一个方法,非终端符号直接调用方法,终端符号直接转化为TOKEN,所以一个方法中左侧不能调用方法本身否则会出现无限递归解析.所以我们在解析表达式时,要考虑各个运算符的优先级,比如说:1+2*3应该让乘法先解析,如果画成语法树的形式,那么低优先级的运算符号应该更加靠近根节点,按照自上而下的顺序来描述表达式的规则. 项的分析表示项的符号是term().12345678910111213141516171819202122//项的语法term():&#123;&#125;&#123; LOOKAHEAD(\"(\" type()) \"(\" type() \")\" term() //带强制类型转换的情况 | unary()&#125;//前置运算符语法unary();&#123;&#125;&#123; \"++\"term() | \"--\"term() | \"-\" term() | \"+\" term() | \"~\" term() | \"!\" term() | \"*\" term() | \"&amp;\" term() | LOOKAHEAD(3) &lt;SIZEOF&gt; \"(\" type() \")\" //sizeof(类型) | &lt;SIZEOF&gt; unary() //sizeof(表达式) | postfix()&#125;//后置运算符语法 JavaCC的action语法规则检查的同时需要生成语法树,,要借助action功能,一个简单的action的例子,是对结构体语法的扩充:1234567void defstruct():&#123;&#125;&#123; &lt;STRUCT&gt; name() member_list() \";\" &#123; System.out.println(\"发现了结构体!\"); &#125;&#125; 在符号之后用一个大括号围起来的java代码,解析到该符号串时就会触发该代码.另外,开头要标注一个语义值,相当于返回值类型.带有返回值的action:1234567String defstruct():&#123;&#125;&#123; &lt;STRUCT&gt; name() member_list() \";\" &#123; return \"struct\"; &#125;&#125; 还能获取终端符号或者非终端符号的语义值:1234567STRING name():&#123; Token tok;//定义临时变量&#125;&#123; tok=&lt;INDENTIFIER&gt; &#123;return tok.image;&#125;//获取&lt;I&gt;的语义值并返回其语义值(.image()方法返回字面量)&#125; Token类中定义的属性,参见96页表格.非终端符号的语义值获取唯一要主要的就是,终端符号的类型都是Token,非终端符号各不相同.接下来就是将之前定义的语法全部扩充成有返回值的类型. 抽象语法树和节点我们用一个基类Node来表示节点,然后继承得到各种特殊化的节点.所有节点类型的代码放在ast包内.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Node AST //抽象语法树的根节点 ExprNode //表达式节点 AbstractAssignNode //赋值 AssignNode //赋值表达式 OpassignNode //复合赋值表达式(+=,-=) AddressNode //地址表达式(&amp;x) BinaryOpNode //二元运算表达式(x+y) CastNode //类型转换 CondExprNode //条件运算表达式(a?b:c) FuncallNode //函数调用表达式 LHSNode //能成为左值的表达式 VariableNode //变量表达式 ArefNode //数组 DereferenceNode //指针(*ptr) MemberNode //字面量调用成员 PtrMemberNode //指针调用成员 LiteralNode //字面量 IntegerLiteralNode //整数字面量 StringLiteralNode //字符串 SizeofExprNode //sizeof表达式 SizeofTypeNode //计算类型的sizeof表达式 UnaryOpNode //一元运算表达式(-x,~x) UnaryArithmeticOpNode //++和--运算符 PrefixOpNode //前置 SuffixOpNode //后置 Slot //结构体成员 StmtNode //表示语句的节点 BlockNode //程序块 BreakNode //break语句 WhileNode DoWhileNode ForNode GotoNode LabelNode //带标签的语句 ReturnNode IfNode SwitchNode CaseNode ContinueNode ExprStmtNode //能独立成语句的表达式 TypeDefinition //类型定义 CompositeTypeDefinition //结构体或联合体定义 StructNode UnionNode TypedefNode //类型重命名 TypeNode //类型的节点 其中比较重要的有: AST 根节点 StmtNode 表示语句的节点的基类 ExprNode 表示表达式的节点的基类 TypeDefinition 定义类型的节点的基类 类型123456789101112131415161718192021Type //基本类型 ArrayType IntegerType FunctionType VoidType PointerType NamedType //抽象出的自命名的类型 CompositeType //组合类型 UnionType StructType UserType //typedef的类型TypeRef ArrayTypeRef FunctionTypeRef IntegerTypeRef PointerTypeRef StructTypeRef UnionTypeRef UserTypeRef VoidTypeRefTypeTable ref类型的作用TypeRef和Type的区别在与,前者是类型的名称,后者是类型的定义.比如解析struct s point;struct s {int x;},那么在定义struct s类型之前就遇到了其类型的变量,在寻找其type类型时找不到该类型的定义.所以解决方法是先仅记录名称,然后在转换为Type对象.因此在Parser中生成的都是ref类型. 一元运算符的解析如果有x-&gt;y-&gt;z这样的语法怎样解析呢?我们知道首先解析出token x,’-&gt;’成员调用符号和token y,那么状态转变为创造一个MemberNode节点,含有一个创造的调用表达式x,然后调用的对象是y,这样就完成了,继续解析出”-&gt;”和z,那么之前的MemberNode成为一个调用表达式,调用的对象为y,这样可以递归的进行. 左结合与右结合1-2-3左结合,要用表达式expr1() (&quot;-&quot; expr1())*来解析,赋值语句x=y=z应该是右结合,所以需要expr():{}{term() &quot;=&quot; expr()}来解析.两种解析方法可以解析相同的语句,但是得到的语法树不同. 语句的语法树关于location的调用,每个节点都有一个location方法,包含一个Location对象,记录了节点所在的文件名和行号. 函数定义的抽象语法树123456789101112131415DefinedFunction defun():&#123; boolean priv; TypeRef ret; String name; Params pl; BlockNode body;&#125;&#123; priv=storage() ret=typeref() name=name()\"(\"pl=params() \")\" body=block() &#123; TypeRef t=new FunctionTypeRef(ret,pl.parametersTypeRef()); return new DefinedFunction(priv,new TypeNode(t),n,ps,body); &#125;&#125; 一个函数包括是否是静态,返回类型,函数名,形参列表,函数体.一个type是一个类型定义,一个typeref版本的只是这个类型的名字,所以我们在声明函数的时候要用ref,定义函数要返回一个type的子类.可以说每种类型的type类中包含有typeref的信息. 声明列表的语法树声明列表为top_defs(),返回一个Declarations类,用这个类来保存所有定义的类型.相当于一个容器来存储. 1234567891011121314151617181920212223242526272829Declarations top_defs():&#123; Declarations decls=new Declarations(); DefinedFunction defun; List&lt;DefinedVariable&gt; defvars; Constant defconst(); StructNode defstruct; UnionNode defunion; TypeDefNode deftype;&#125;&#123; (LOOKAHEAD(storage() typeref() &lt;INDENTIFIER&gt; \"(\") defun()//函数定义 &#123;decls.addDefun(defun);&#125; | LOOKAHEAD(3) defvars=defvars()//变量定义 &#123;decls.addDefvars(defvars); | defconst=defconst()//常量定义 &#123;decls.addConstant(defconst);&#125; | defstruct=defstruct()//结构体定义 &#123;decls.addDefstruct(defstruct);&#125; | defunion=defunion()//联合体定义 &#123;decls.addDefunion(defunion);&#125; | deftype=typedef()//类型别名 &#123;decls.addTypedef(deftype);&#125; )* &#123; return decls; &#125;&#125; 表示程序整体的语法树12345678910111213141516//一个编译单位,即一个文件的总体规则,import语句+函数或类型定义+文件结尾AST compilation_unit():&#123; Token t; Declarations impdecls,decls;&#125;&#123; &#123; t=getToken(1);//这个方法是JavaCC预定义在Parser类中的方法,可以得到一个token &#125; impdecls=import_stmts() decls=top_defs() &lt;EOF&gt; &#123; decls.add(impdecls); //两者先和并. return new AST(location(t),decls); &#125;&#125; 声明类型的解析import的文件中不含有定义,只含有变量,函数和类型的声明,函数和变量的用Undefinedxxx代替了DefinedXXX.其他的节点生成是一样的.声明的语法如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//多个import行,每个行用loader加载器加载得到一个Declarations,然后用impdecls合并所有的import.Declarations import_stmts():&#123; Declarations impdecls=new Declaration(); String libid;&#125;&#123; (libid=import_stmt() &#123; try&#123; Declarations decls=loader.loadLibary(libid,errorHandler); if(decls!=null)&#123; impdecls.add(decls); addKnownTypedefs(decls.typedefs()); &#125; &#125;catch(CompileException e)&#123; throw new ParseException(e.getMessage()); &#125; )*&#125;//一个import行的语法String import_stmt():&#123; StringBuilder name; String s;&#125;&#123; &lt;IMPORT&gt; name()&#123; name.append(s);&#125; ( \".\" name()&#123;name.append(\".\"+s);&#125; )* \";\" &#123; return name.toString(); &#125;&#125;//解析声明文件的语法Declarations declaration_file():&#123; Declarations impdecls, decls = new Declarations(); UndefinedFunction funcdecl; UndefinedVariable vardecl; Constant defconst; StructNode defstruct; UnionNode defunion; TypedefNode typedef;&#125;&#123; impdecls=import_stmts() &#123; decls.add(impdecls); &#125; ( LOOKAHEAD(&lt;EXTERN&gt; typeref() &lt;IDENTIFIER&gt; \"(\") funcdecl=funcdecl() &#123; decls.addFuncdecl(funcdecl); &#125; | vardecl=vardecl() &#123; decls.addVardecl(vardecl); &#125; | defconst=defconst() &#123; decls.addConstant(defconst); &#125; | defstruct=defstruct() &#123; decls.addDefstruct(defstruct); &#125; | defunion=defunion() &#123; decls.addDefunion(defunion); &#125; | typedef=typedef() &#123; decls.addTypedef(typedef); &#125; )* &lt;EOF&gt; &#123; return decls; &#125;&#125; 至此,基本上我们parser的解析器的部分就完成了,还有就是Parser类的一些工具方法,都是一些解字符串,转义字符和数值转字符的事情.","tags":[{"name":"JAVASE","slug":"JAVASE","permalink":"http://yoursite.com/tags/JAVASE/"},{"name":"编译器","slug":"编译器","permalink":"http://yoursite.com/tags/编译器/"},{"name":"C--","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"仿c语言自制编程语言笔记1","date":"2018-01-14T13:11:31.000Z","path":"2018/01/14/仿c语言自制编程语言笔记1/","text":"编译的流程对于c语言这种,需要经历四个过程: 预处理 (狭义的)编译 汇编 链接第一步,由预处理器对一些宏进行展开和一些包括的头文件进行填充,不考虑其他语法含义.第二步,需要生成汇编语言,也就是扩展名为”.s”的文件,内容是接近机器语言的汇编代码.第三步,由汇编器转换为机器语言,内容是机器可执行的二进制文件,后缀名为”.o”,也称为目标文件.还需要进行一步链接,有些需要用库,这一步可以对程序库进行加载.在jvm中,使用了JIT编译器,能够在程序运行时将程序转换为机器语言的编译器. 编译的阶段词法分析对代码进行每个词的词法分析,用一些结构体将每个合法的词解析出来.比如”x=1+2”,分割成五个单词,并且识别出是单词的语义. 语法分析词法分析后需要进行语法分析,转换为”语法树”. 语义分析通过解析代码获得语法树后,需要对树进行处理生成抽象语法树(AST),语义分析包括: 区分变量为局部变量还是全局变量 解析变量的声明和引用 变量和表达式的类型检查 检查在引用变量之前是否进行了初始化 检查函数是否按照定义返回了结果 上述处理结果都会反应到抽象语法树中,语法分析生成的语法树只是将代码的构造搬了过来. 生成中间代码将抽象语法树转化为只在编译器内部使用的中间代码,为了支持多种编程语言或者机器语言. 代码生成中间代码转化为汇编语言,称为代码生成,负责这个模块的称为代码生成器.比如说汇编语言中局部变量只能通过寄存器来存放,寄存器数量非常有限而c或java都可以随意定义局部变量. cmm概要仿c语言语法的编程语言c–,cmm相对c语言除去的功能: 预处理器,改用java中的import 浮点数 enum枚举 结构体的位域 结构体和联合体的赋值和返回值 逗号表达式 const,volatile,auto,register 添加了boolean关键字 对于语义规则更加严格.import关键字语法类似如下:12import stdio;import sys.params; 后缀名为’.cmm’的类似于c语言中的源文件,后缀名为’.hm’的为头文件,一般包含下述声明: 函数声明 变量声明(不可包含初始值的定义) 常量定义(这里必须有初始值) 结构体定义 联合体定义 typedef比如stdio.hm的内容:12345import stddef;import stdarg;typefef unsigned long FILE;// dummyextern FILE* stdin;... cmc编译器的代码构成 包 包中的类 asm 汇编对象的类 ast 抽象语法树的类 compiler Compiler类等编译器的核心类 entity 表示函数和变量等实体的类 exception 异常的类 ir 中间代码的类 parser 解析器类 sysdep 包含依赖于OS的代码的类(汇编器和链接器) sysdep.x86 包含依赖于OS和CPU代码的类(代码生成器) type 表示cb的类型的类 utils 小的工具类 一个大致的流程: 首先看Compiler包,其中包含了一个Compiler类,有main入口,也就是编译的入口 由传入的命令行参数得到所有源文件的名字. 调用build方法对源文件进行编译,首先用compile得到汇编文件.然后用assemble运行汇编器,转换为目标文件. 其中compile完成编译器前端部分,首先用对源文件用parser得到AST,然后语义分析完成抽象语法树.最后一个IR类生成中间代码. 解析器javaCC解析器的作用是,规定好语法,自动生成解析相应语法的代码.否则手动编写NFA转DFA,状态转移表,LL算法,手动生成语法树.javaCC是LL解析器,语法规则用一个”.jj”的文件来描述,称为语法描述文件.首先,文件的大致格式如下:123456789101112131415options&#123;JAVA的选项&#125;PARSER_BEGIN(解析器类名)package 包名;import 库名;public class 解析器类名&#123; //任意java代码&#125;PRASER_END(解析器类名)扫描器的描述解析器的描述 举个加法的例子:123456789101112131415161718192021222324252627282930313233343536373839options&#123;STATIC = false;&#125;PARSER_BEGIN(Adder)import java.io.*;class Adder&#123; static public void main(String[] args)&#123; for(String arg:args)&#123; try&#123; System.out.println(evaluate(arg)); &#125; catch(ParseException e)&#123; System.err.println(e.getMessage()); &#125; &#125; &#125; static public long evaluate(String src)throws ParseException&#123; Reader reader=new StringReader(src); return new Adder(reader).expr(); &#125;&#125;PARSER_END(Adder)SKIP: &#123; &lt;[\" \",\"\\t\",\"\\n\",\"\\r\"]&gt; &#125;TOKEN:&#123; &lt; INTEGER:([\"0\"-\"9\"])+ &gt;&#125;long expr():&#123; Token x,y;&#125;&#123;x=&lt;INTEGER&gt;\"+\"y=&lt;INTEGER&gt;&lt;EOF&gt; &#123; return Long.parseLong(x.image)+Long.parseLong(y.image); &#125;&#125; 注意,要运行javaCC生成的解析器类,需要下面两个步骤: 生成解析器类的对象实例(上例Adder就是一个解析器类) 用生成的对象调用和需要解析的语句同名的方法.(也就是调用expr()) JavaCC生成的解析器中默认定义有如下4个类型的构造函数: Parser(inputStream s) Parser(inputStream s,String encoding)//如果要解析中文必须用这个或者下面的构造函数,并且在设置里将UNICODE_INPUT设为true. Parser(Reader r) Parser(xxxxTokenManager tm)","tags":[{"name":"JAVASE","slug":"JAVASE","permalink":"http://yoursite.com/tags/JAVASE/"},{"name":"编译器","slug":"编译器","permalink":"http://yoursite.com/tags/编译器/"},{"name":"C--","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Java学习笔记11","date":"2017-12-28T12:28:07.000Z","path":"2017/12/28/Java学习笔记11/","text":"day12NIOjava.nio.ByteBuffer,这个类有写模式和读模式，区别在于我们对缓冲区写后，limit处于最大的分配长度，需要调用flip()用来改为读模式，这样limit就为我们写入的实际数据的长度，并且开始的位置归到0。 缓冲器有四个标志: mark position limit capacity 内存映射文件1234567891011121314151617181920212223242526public class LargeMappedFiles &#123; static int length=0x8FFFFFF;//128MB public static void main(String[] main)throws Exception&#123; MappedByteBuffer out=new RandomAccessFile(\"test.dat\", \"rw\") .getChannel().map(FileChannel.MapMode.READ_WRITE,0, length); for(int i=0;i&lt;length;i++)&#123; out.put((byte)'x'); &#125; for(int i=length/2;i&lt;length/2+6;i++)&#123; System.out.println((char)out.get(i)); &#125; &#125;&#125; 通过调用getChannel返回一个通道，然后调用map方法，指定映射的范围，返回一个MappedByteBuffer类缓冲器，可以进行所有缓冲器的操作。 测试性能代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184package io;import java.util.*;import javax.swing.event.TreeSelectionEvent;import org.omg.CosNaming.NamingContextExtPackage.StringNameHelper;import java.io.*;import java.nio.*;import java.nio.channels.*;public class MappedIO &#123; private static int numOfInts=4000000; private static int numOfUbuffInts=200000; private static String filename=\"temp.tmp\"; private abstract static class Tester&#123; private String name; public Tester(String name)&#123;this.name=name;&#125; public abstract void test()throws IOException; public void runTest()&#123; System.out.print(name+\": \"); try&#123; long start=System.nanoTime(); test(); double time=(System.nanoTime()-start)/1.0e9; System.out.println(time); &#125;catch (IOException e) &#123; throw new RuntimeException(e);// TODO: handle exception &#125; &#125; &#125; private static Tester[] tests=&#123;new Tester(\"Stream Write\")&#123; public void test()throws IOException&#123; DataOutputStream out=new DataOutputStream( new BufferedOutputStream( new FileOutputStream( new File(filename) ) ) ); for(int i=0;i&lt;numOfInts;i++) out.writeInt(i); out.close(); &#125; &#125;, new Tester(\"Mapped Write\")&#123; public void test()throws IOException&#123; FileChannel fc=new RandomAccessFile(filename,\"rw\") .getChannel(); IntBuffer out= fc.map(FileChannel.MapMode.READ_WRITE,0,fc.size()).asIntBuffer(); for(int i=0;i&lt;numOfInts;i++)&#123; out.put(i); &#125; fc.close(); &#125; &#125;, new Tester(\"Stream Read\")&#123; public void test()throws IOException&#123; DataInputStream in=new DataInputStream( new BufferedInputStream( new FileInputStream(filename) ) ); for(int i=0;i&lt;numOfInts;i++)&#123; in.readInt(); &#125; &#125; &#125;, new Tester(\"Maped Read\")&#123; public void test()throws IOException&#123; FileChannel fc=new RandomAccessFile(filename,\"rw\").getChannel(); IntBuffer ip=fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size()).asIntBuffer(); while(ip.hasRemaining())&#123; ip.get(); &#125; fc.close(); &#125; &#125; &#125;; public static void main(String[] args)&#123; for(Tester t:tests)&#123; t.runTest(); &#125; &#125;&#125;/*outputStream Write: 0.935622322Mapped Write: 0.20189704Stream Read: 0.807558947Maped Read: 0.048553753*/ 性能上来说，映射读写速度远大于缓冲io，不过容易频繁换页。 对象序列化目的：对象在进程结束后自动销毁，为了让对象能继续存在使得下一次运行程序能直接使用。 用途：支持两种特性，一是Java的远程方法调用，使得存活于其他计算机上的对象使用起来就像是存活于本机上一样，当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值。二是在JAVAbeans中的应用。 注意，对象序列化关注对象的“状态”，不会关注对象的静态变量。 下面是一个存储、恢复实例，用到了一个worm类能迭代引用多个worm，这个例子说明了恢复时不仅能恢复对象本身的状态，还能恢复对象引用的其他对象的状态。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144class Data implements Serializable&#123; private int n; public Data(int n) &#123; this.n=n; &#125; public String toString()&#123; return Integer.toString(n); &#125;&#125;public class Worm implements Serializable &#123; private static Random rand=new Random(47); private Data[] datas=&#123; new Data(rand.nextInt(10)), new Data(rand.nextInt(10)), new Data(rand.nextInt(10)) &#125;; private Worm next; private char c; public Worm(int i,char x)&#123; System.out.println(\"Worm constructor: \"+i); this.c=x; if(--i&gt;0) next=new Worm(i, (char)(x+1)); else&#123; next=null; &#125; &#125; public Worm()&#123; System.out.println(\"Default Constructor\"); &#125; public String toString()&#123; StringBuilder result=new StringBuilder(\":\"); result.append(c); result.append(\"(\"); for(Data d:datas)&#123; result.append(d+\" \"); &#125; result.append(\")\"); if(this.next!=null)&#123; result.append(this.next.toString()); &#125; return result.toString(); &#125; public static void main(String[] args)throws IOException,ClassNotFoundException&#123; Worm w=new Worm(6,'a'); System.out.println(\"w= \"+w); ObjectOutputStream out=new ObjectOutputStream( new FileOutputStream(\"worm.out\")); out.writeObject(\"Worm storage\\n\"); out.writeObject(w); out.close(); ObjectInputStream in=new ObjectInputStream( new FileInputStream(\"worm.out\")); String s=(String)in.readObject(); Worm w2=(Worm)in.readObject();//没有调用任何构造器 System.out.println(s+\"w= \"+w2); &#125;&#125;/*outputWorm constructor: 6Worm constructor: 5Worm constructor: 4Worm constructor: 3Worm constructor: 2Worm constructor: 1w= :a(8 5 3 ):b(1 1 9 ):c(8 0 2 ):d(7 8 8 ):e(1 9 9 ):f(8 8 1 )Worm storagew= :a(8 5 3 ):b(1 1 9 ):c(8 0 2 ):d(7 8 8 ):e(1 9 9 ):f(8 8 1 )*/ 可以从结果看到，整个过程没有调用任何构造器，对象直接从数据中恢复过来。 另外，我们在用序列化文件还原某个对象时，一定要有该对象的.class文件能被虚拟机找到。 序列化控制考虑安全问题，希望序列化的对象中一部分内容不进行序列化，需要用Externalizable接口，这个接口继承了Serializable接口并增加了两个方法，*而且不同与前者的是，这个接口读取序列化对象时一定调用默认构造器，如果构造器没有public的话会报异常。下面这个例子展示了如何序列化部分内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106class Blip3 implements Externalizable&#123; private int i; private String s; public Blip3()&#123; System.out.println(\"Blip3 Constructor\"); &#125; public Blip3(String x,int a)&#123; System.out.println(\"Blip3(String,int) Constructor\"); this.i=a; this.s=x; &#125; public String toString()&#123; return s+i; &#125; public void writeExternal(ObjectOutput out)throws IOException&#123; System.out.println(\"Blip2.writeExternal\"); out.writeInt(i); out.writeObject(s); &#125; public void readExternal(ObjectInput in)throws IOException,ClassNotFoundException&#123; System.out.println(\"Blip2.readExternal\"); this.i=in.readInt(); this.s=(String)in.readObject(); &#125;&#125;public class Blips &#123; public static void main(String[] args)throws IOException,ClassNotFoundException&#123; System.out.println(\"Constructing objects:\"); //Blip1 b1=new Blip1(); //Blip2 b2=new Blip2(); Blip3 b3=new Blip3(\"A\",7); ByteArrayOutputStream bout=new ByteArrayOutputStream(); ObjectOutputStream out=new ObjectOutputStream(bout); //out.writeObject(b1); //out.writeObject(b2); out.writeObject(b3); out.close(); ObjectInputStream in=new ObjectInputStream( new ByteArrayInputStream(bout.toByteArray())); Object b4=in.readObject(); //b4=in.readObject(); //b4=in.readObject(); System.out.println(b4.toString()); &#125;&#125;/*outputConstructing objects:Blip3(String,int) ConstructorBlip3.writeExternalBlip3 ConstructorBlip3.readExternalA7*/ 可以看到，我们需要实现两个方法writeExternal(ObjectOutput)和inputExternal(ObjectInput)，在这两个方法中自己来定义要序列的内容和读取的内容。 transient如果对继承了Serializable接口的对象中部分内容不想序列化，就得使用transient(瞬时）关键字来指定内容不可序列化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* * 假如某个Login对象保存某个特定的登录会话信息，登录的合法性通过校验之后， * 我们想把数据保存下来，但不包括密码 */import java.io.*;import java.util.*;import java.util.concurrent.TimeUnit;public class Logon implements Serializable&#123; private Date date=new Date(); private String username; private transient String password; public Logon(String name,String pwd)&#123; username=name; password=pwd; &#125; public String toString()&#123; return \"Logon info:\\nusername: \"+username+ \"\\nDate: \"+date+\"\\npassword: \"+password; &#125; public static void main(String[] args)throws Exception&#123; Logon a= new Logon(\"Hulk\", \"myLittlePony\"); System.out.println(\"logon a= \"+a); ObjectOutputStream out=new ObjectOutputStream( new FileOutputStream(\"Login.out\")); out.writeObject(a); out.close(); TimeUnit.SECONDS.sleep(1); ObjectInputStream in=new ObjectInputStream( new FileInputStream(\"Login.out\")); a=(Logon)in.readObject(); System.out.println(a); &#125;&#125;/*outputlogon a= Logon info:username: HulkDate: Tue Dec 26 22:04:51 CST 2017password: myLittlePonyLogon info:username: HulkDate: Tue Dec 26 22:04:51 CST 2017password: null*/ 从结果发现，密码的引用是null，因为没有被存储，也不会被反序列化，对象引用如果是null，自动转成null字符串。 XML","tags":[{"name":"JAVASE","slug":"JAVASE","permalink":"http://yoursite.com/tags/JAVASE/"}]},{"title":"Java学习笔记10","date":"2017-12-28T12:21:49.000Z","path":"2017/12/28/Java学习笔记10/","text":"day11I/0 ###目录列表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.*;import java.util.regex.*;import java.io.*;class DirFilter implements FilenameFilter&#123;//这个接口只有一个方法accept private Pattern pattern; public DirFilter(String regex)&#123; pattern=Pattern.compile(regex); &#125; public boolean accept(File dir,String name)&#123; return pattern.matcher(name).matches(); &#125;&#125;public class DirList &#123; public static void main(String[] args)&#123; File path=new File(\"src/io\"); String[] list; //list=path.list(); list=path.list(new DirFilter(\"D.*.java\")); Arrays.sort(list,String.CASE_INSENSITIVE_ORDER); for(String dirItem:list)&#123; System.out.println(dirItem); &#125; &#125;&#125; File的list()方法可以返回当前目录下的所有文件，FilenameFilter接口的accept方法供list()调用，可以起到过滤器的作用，其中传一个正则表达式用来过滤不符合表达式的文件名。 获取文件集123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198package io;import java.util.regex.*;import java.io.*;import java.util.*;//用来打印的格式class PPrint&#123; public static String pformat(Collection&lt;?&gt;c)&#123; if(c.size()==0)return \"[]\"; StringBuilder result= new StringBuilder(\"[\"); for(Object obj:c)&#123; if(c.size()!=1) result.append(\"\\n \"); result.append(obj.toString()); &#125; if(c.size()!=1)&#123; result.append(\"\\n\"); &#125; result.append(\"]\"); return result.toString(); &#125;&#125;//用来递归获取目录中文件夹和文件的名字public class Directory &#123; public static File[] local(File dir,final String regex)&#123; return dir.listFiles(new FilenameFilter()&#123; private Pattern pattern =Pattern.compile(regex); public boolean accept(File dir,String name)&#123; return pattern.matcher(name).matches(); &#125; &#125;); &#125; public static File[] local(String path,final String regex)&#123; return local(new File(path), regex); &#125; // public static class TreeInfo implements Iterable&lt;File&gt;&#123; //用来存放文件和文件夹的名称。 public List&lt;File&gt; files=new ArrayList&lt;File&gt;(); public List&lt;File&gt; dirs=new ArrayList&lt;File&gt;(); public Iterator&lt;File&gt; iterator()&#123; return files.iterator(); &#125; public void addFile(File file)&#123; files.add(file); &#125; public void addDir(File dir)&#123; dirs.add(dir); &#125; public void addAll(TreeInfo other)&#123; this.files.addAll(other.files); this.dirs.addAll(other.dirs); &#125; public String toString()&#123; return \"dirs\"+PPrint.pformat(dirs)+\"\\n\\nfiles:\"+PPrint.pformat(files); &#125; &#125; public static TreeInfo walk(String start,String regex)&#123; return recurseDirs(new File(start), regex); &#125; public static TreeInfo walk(String start)&#123; return recurseDirs(new File(start), \".*\"); &#125; public static TreeInfo walk(File start,String regex)&#123; return recurseDirs(start, regex); &#125; public static TreeInfo walk(File start)&#123; return recurseDirs(start, \".*\"); &#125; // static TreeInfo recurseDirs(File startDir,String regex)&#123; TreeInfo result=new TreeInfo(); for(File file:startDir.listFiles())&#123; if(file.isDirectory())&#123; result.addDir(file); result.addAll(recurseDirs(file, regex)); &#125; else if(file.getName().matches(regex))&#123; result.addFile(file); &#125; &#125; return result; &#125; public static void main(String[] args)&#123; if(args.length==0)&#123; System.out.println(walk(\".\")); &#125;else&#123; for(String arg:args)&#123; System.out.println(walk(arg)); &#125; &#125; &#125;&#125; File类也可以用来创建新的目录或尚不存在的整个目录路径。我们还可以查看文件的特性(如：大小，最后修改日期，读写）类似于unix接口中的fcntl。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package io;import java.io.*;public class MakeDirectories &#123; private static void usage()&#123; System.err.println( \"\"); System.exit(1); &#125; private static void fileData(File f)&#123; System.out.println( \"Absolute path: \"+f.getAbsolutePath()+\"\\n\" + \"Can read: \"+f.canRead()+\"\\n\" +\"getName: \"+f.getName()+\"\\n\" +\"getParent: \"+f.getParent()+\"\\n\" +\"getPath: \"+f.getPath()+\"\\n\" +\"length: \"+f.length()+\"\\n\" +\"lastModified: \"+f.lastModified() );//可以查看的一些信息 if(f.isFile()) System.out.println(\"It is a File\"); else if(f.isDirectory()) System.out.println(\"It is a directory\"); &#125; public static void main(String[] args)&#123; if(args.length&lt;1)usage(); if(args[0].equals(\"-r\"))&#123; if(args.length!=3)usage(); File old=new File(args[1]); File rname=new File(args[2]); old.renameTo(rname);//rename一个文件或者文件夹 fileData(old); fileData(rname); return; &#125; int count=0; boolean del=false; if(args[0].equals(\"-d\"))&#123; count++; del=true; &#125; count--; while(++count&lt;args.length)&#123; File f=new File(args[count]); if(f.exists())&#123; System.out.println(f+\"exists\"); if(del)&#123; System.out.println(\"deleting...\"+f); f.delete(); &#125; &#125; else&#123; if(!del)&#123; f.mkdirs(); System.out.println(\"Created\"+f); &#125; &#125; fileData(f); &#125; &#125;&#125; 输入输出InputStream 作用是用来表示哪些从不同数据源产生的输入的类，这些数据源包括: 字节数组 String对象 文件 *“管道”，工作方式与实际管道相似。 一个由其他种类的流组成的序列，以便我们可以将它们手机合并到一个流内。 其他数据源，如Internet连接 outputStream 各种继承的类表示了要去往的目标： ByteArrayOutputStream 字节数组 FileOutputStream 文件 PipedOutputStream 管道 FilterOutputStream 抽象基类，提供过滤功能 类库中各种类的模式基于装饰器模式，即一种IO核心类型加上所有的装饰器，组成一个IO对象。 Reader和Writer为了国际化，老IO类库只能支持8位，Unicode需要支持16位。 实例 缓冲读文件(按行读）： 123456789101112131415161718192021222324252627282930313233343536package io;import java.io.*;public class BufferedInputFile &#123; public static String read(String filename)throws IOException&#123; BufferedReader in =new BufferedReader(new FileReader(filename)); String s; StringBuilder sb=new StringBuilder(); while((s=in.readLine())!=null)&#123; sb.append(s+'\\n'); &#125; in.close(); return sb.toString(); &#125; public static void main(String[] args) throws IOException&#123; System.out.println(new File(\".\").getAbsoluteFile()); &#125;&#125; 从内存读 12345678910111213141516171819202122public class MemoryInput &#123; public static void main(String[] args)throws IOException&#123; //先由BufferedInputFile读到内存，返回一个String给StringReader StringReader in=new StringReader(BufferedInputFile.read(\"Memory.java\")); int c; while((c=in.read())!=-1)&#123; System.out.println(c); &#125; &#125;&#125; 格式化的内存输入 用DataInputStream，面向字节，而不是面向字符（char占两个字节） 基本文件输出 123456789101112131415161718192021222324252627282930public class BasicFileOutput &#123; static String file=\"BasicFileOutput.out\"; public static void main(String[] args)throws IOException&#123; BufferedReader in=new BufferedReader( new StringReader(BufferedInputFile.read(\"./src/io/BasicFileOutput.java\"))); PrintWriter out=new PrintWriter(new BufferedWriter(new FileWriter(file))); int linecount=1; String s; while((s=in.readLine())!=null)&#123; out.println(linecount+++\":\" +s); &#125; out.close();//要显示调用close，刷新缓冲区 System.out.println(BufferedInputFile.read(file)); &#125;&#125; 标准IO 重定向方法： setIn(InputStream) setOut(PrintStream) setErr(PrintStream) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Redirecting &#123; public static void main(String[] args)throws IOException&#123; PrintStream console=System.out; BufferedInputStream in= new BufferedInputStream( new FileInputStream(\"./src/io/Redirecting.java\") ); PrintStream out=new PrintStream( new BufferedOutputStream( new FileOutputStream(\"test.out\") ) ); System.setIn(in); System.setOut(out); System.setErr(out); BufferedReader br=new BufferedReader( new InputStreamReader(System.in) ); String s; while((s=br.readLine())!=null)&#123; System.out.println(s); &#125; out.close(); System.setOut(console); &#125;&#125;","tags":[{"name":"JAVASE","slug":"JAVASE","permalink":"http://yoursite.com/tags/JAVASE/"}]},{"title":"Java学习笔记9","date":"2017-12-28T12:09:57.000Z","path":"2017/12/28/Java学习笔记9/","text":"day10Class.newInstance和Constructor.newInstance()首先来分析new和newInstance(),在使用new来创建一个对象时，我们必须知道这个对象的确切类型，而用newInstance()不知道知道确切类型，通过反射来创建实例。 我们知道newInstance()是通过类加载机制，也就是说，要加载过我们要创建的类型，才能创建对象实体。 Class.newInstance() 只能够调用无参的构造函数，即默认的构造函数； Constructor.newInstance() 可以根据传入的参数，调用任意构造构造函数。 Class.newInstance() 抛出所有由被调用构造函数抛出的异常。 Class.newInstance() 要求被调用的构造函数是可见的，也即必须是public类型的; Constructor.newInstance() 在特定的情况下，可以调用私有的构造函数。 队列QueueQueue在SE5中仅有的两个实现是LinkedList和PriorityList，其中，优先级队列的排列规则按照对象类型实现的Comparable控制。 使用方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package wangliang;import java.util.*;import java.util.concurrent.*;public class QueueBeahavior &#123; private static int count=10; static &lt;T&gt; void test(Queue&lt;T&gt; queue,Generator&lt;T&gt; gen)&#123; for(int i=0;i&lt;count;i++)&#123; queue.offer(gen.next());//offer用来入队的方法，还有个add &#125; while(queue.peek()!=null)&#123; System.out.print(queue.remove()+\" \");//remove返回队首元素并从队中删除。 &#125; System.out.println(); &#125; static class Gen implements Generator&lt;String&gt;&#123; String[] s=(\"one two three four five six seven eight nine ten\").split(\" \"); int i=0; public String next()&#123;return s[i++];&#125; &#125; public static void main(String[] args)&#123; test(new LinkedList&lt;String&gt;(),new Gen()); test(new PriorityQueue&lt;String&gt;(), new Gen()); test(new ArrayBlockingQueue&lt;String&gt;(count),new Gen()); test(new PriorityBlockingQueue&lt;&gt;(), new Gen()); &#125;&#125; 深入理解MapMap里面总共6个实现： HashMap TreeMap LinkedHashMap//LinkedHashMap可以使用最近最少算法，使得没有被访问的元素放在前面。 WeakHashMap ConcurrentHashMap IdentityHashMap 散列与散列码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package wangliang;import java.lang.reflect.Constructor;import java.util.Map;import java.util.Random;import java.util.*;class Prediction&#123; private static Random rand=new Random(47); private boolean shadow=rand.nextDouble()&gt;0.5; public String toString()&#123; if(shadow)&#123; return \"Six more weeks of Winter\"; &#125;else&#123; return \"Early Spring\"; &#125; &#125;&#125;public class SpringDetector &#123; public static &lt;T extends Groundhog&gt;void detectSpring(Class&lt;T&gt; type) throws Exception&#123; Constructor&lt;T&gt; ghog=type.getConstructor(int.class); Map&lt;Groundhog, Prediction&gt;map=new HashMap&lt;Groundhog,Prediction&gt;(); for(int i=0;i&lt;10;i++)&#123; map.put(ghog.newInstance(i), new Prediction()); &#125; System.out.println(\"map=\"+map); Groundhog gh=ghog.newInstance(3); System.out.println(\"Looking up for\"+gh); if(map.containsKey(gh))&#123; System.out.println(map.get(gh)); &#125;else System.out.println(\"Not Found\"+gh); &#125; public static void main(String[] args) throws Exception&#123; detectSpring(Groundhog.class); &#125;&#125;/*outputnot found*/ 原因是因为我们的Groundhog类没有重写hashCode()，继承自Object的方法，Object中equals()用对象的内存地址来散列，因此我们用两个属性相同的对象散列后不想等。 创建equals()满足的条件： 自反性。任意x,x.equals(x)must return true。 对称性。任意x和y,如果x.equals(y)return true then y.equals(x)return true 传递性。 一致性。 对任何不是null的x，x.equals(null)must return false。 容器选择List给出了两种容器的性能对比： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408/*代码结构：首先有一个Test抽象类，主要用来实现各种方法的对象。有一个test()方法可以重写，根据具体实现方法用匿名内部类方法实现。其次有一个Tester类，这个类含有一个指定的容器和存储各种参数下Test类的list，负责打印各种参数下test()的结果。最后一个listPerformance类，用来添加具体测试的方法和参数。//Tester.javapackage wangliang;import java.util.*;public class Tester&lt;C&gt; &#123; public static int fieldWidth=8;//打印宽度 private static int sizeWidth=5; private static String sizeField=\"%\"+sizeWidth+\"s\"; private static String stringField()&#123; return \"%\"+fieldWidth+\"s\"; &#125; private static String numberField()&#123; return \"%\"+fieldWidth+\"d\"; &#125; public static TestParam[] defaultParams=TestParam.array( 10,5000,100,5000,1000,5000,10000,500); protected C initialize(int size)&#123; return container; &#125; protected C container; private String headline=\"\"; private List&lt;Test&lt;C&gt;&gt;tests; private TestParam[] paramList=defaultParams; public Tester(C container,List&lt;Test&lt;C&gt;&gt;tests)&#123; this.tests=tests; this.container=container; if(container!=null)&#123; this.headline=container.getClass().getSimpleName(); &#125; &#125; public Tester(C container,List&lt;Test&lt;C&gt;&gt;tests,TestParam[] paramlist)&#123; this(container,tests); this.paramList=paramlist; &#125; public void setHeadline(String head)&#123; this.headline=head; &#125; //一些通用的方法 public static &lt;C&gt; void run(C cntnr,List&lt;Test&lt;C&gt;&gt;tests)&#123; new Tester&lt;C&gt;(cntnr,tests).timedTest(); &#125; public static &lt;C&gt; void run(C cntnr,List&lt;Test&lt;C&gt;&gt;tests,TestParam[] paramList)&#123; new Tester&lt;C&gt;(cntnr,tests,paramList).timedTest(); &#125; private void displayHeader()&#123; int width=fieldWidth*tests.size()+sizeWidth; int dashLength=width-headline.length()-1; StringBuilder head=new StringBuilder(width); for(int i=0;i&lt;dashLength/2;i++)&#123; head.append(\"-\"); &#125; head.append(\" \"+headline+\" \"); for(int i=0;i&lt;dashLength/2;i++)&#123; head.append(\"-\"); &#125; System.out.println(head); System.out.format(sizeField, \"size\"); for(Test test:tests)&#123; System.out.format(stringField(), test.name); &#125; System.out.println(); &#125; public void timedTest()&#123; displayHeader(); for(TestParam param:paramList)&#123; System.out.format(sizeField, param.size); C kontainer=initialize(param.size); for(Test&lt;C&gt; test:tests)&#123; long start=System.nanoTime(); int reps=test.test(kontainer,param); long timePerRep=(System.nanoTime()-start)/reps; System.out.format(numberField(), timePerRep); &#125; System.out.println(); &#125; &#125;&#125;//ListPerformance.javapackage wangliang;import java.util.ArrayList;import java.util.LinkedList;import java.util.List;import java.util.ListIterator;import java.util.Random;public class ListPerformance &#123; static Random rand=new Random(47); static int reps=1000; static List&lt;Test&lt;List&lt;Integer&gt;&gt;&gt;tests=new ArrayList&lt;Test&lt;List&lt;Integer&gt;&gt;&gt;(); static List&lt;Test&lt;LinkedList&lt;Integer&gt;&gt;&gt;qTests=new ArrayList&lt;Test&lt;LinkedList&lt;Integer&gt;&gt;&gt;(); static&#123; tests.add(new Test&lt;List&lt;Integer&gt;&gt;(\"add\")&#123; int test(List&lt;Integer&gt; list,TestParam tp)&#123; for(int i=0;i&lt;tp.loops;i++)&#123; list.clear(); for(int j=0;j&lt;tp.size;j++) list.add(j); &#125; return tp.loops*tp.size; &#125; &#125;); tests.add(new Test&lt;List&lt;Integer&gt;&gt;(\"get\")&#123; int test(List&lt;Integer&gt;list,TestParam tp)&#123; int loop=tp.loops*reps; for(int i=0;i&lt;loop;i++)&#123; list.get(rand.nextInt(list.size()));//就算是空也可以get() &#125; return loop; &#125; &#125;); tests.add(new Test&lt;List&lt;Integer&gt;&gt;(\"set\")&#123; int test(List&lt;Integer&gt;list,TestParam tp)&#123; int loop=tp.loops*reps; for(int i=0;i&lt;loop;i++)&#123; list.set(rand.nextInt(list.size()), 47); &#125; return loop; &#125; &#125;); tests.add(new Test&lt;List&lt;Integer&gt;&gt;(\"iteradd\")&#123; int test(List&lt;Integer&gt;list,TestParam tp)&#123; final int LOOPS=100000; int half=list.size()/2; list.listIterator(half); ListIterator&lt;Integer&gt;it=list.listIterator(half); for(int i=0;i&lt;LOOPS;i++)&#123; it.add(47);//中间插入 &#125; return LOOPS; &#125; &#125;); tests.add(new Test&lt;List&lt;Integer&gt;&gt;(\"insert\")&#123; int test(List&lt;Integer&gt;list,TestParam tp)&#123; int LOOPS=tp.loops; for(int i=0;i&lt;LOOPS;i++)&#123; list.add(5,47);//中间插入 &#125; return LOOPS; &#125; &#125;); tests.add(new Test&lt;List&lt;Integer&gt;&gt;(\"remove\")&#123; int test(List&lt;Integer&gt;list,TestParam tp)&#123; int loop=tp.loops; int size=tp.size; for(int i=0;i&lt;loop;i++)&#123; list.clear(); list.addAll(new CountingIntegerList(size));//先填满元素 while(list.size()&gt;5)&#123; list.remove(5); &#125; &#125; return loop*size; &#125; &#125;); &#125; static class ListTester extends Tester&lt;List&lt;Integer&gt;&gt;&#123; public ListTester(List&lt;Integer&gt; container,List&lt;Test&lt;List&lt;Integer&gt;&gt;&gt;tests)&#123; super(container,tests); &#125; protected List&lt;Integer&gt;initialize(int size)&#123; container.clear(); container.addAll(new CountingIntegerList(size)); return container; &#125; public static void run(List&lt;Integer&gt;list,List&lt;Test&lt;List&lt;Integer&gt;&gt;&gt;tests)&#123; new ListTester(list, tests).timedTest(); &#125; &#125; public static void main(String[] args)&#123; if(args.length&gt;0)&#123; &#125; Tester&lt;List&lt;Integer&gt;&gt;arrayTest=new Tester&lt;List&lt;Integer&gt;&gt;(null,tests.subList(1,3))&#123; &#125;; Tester.defaultParams=TestParam.array(10,5000,100,5000,1000,1000,10000,200); //Tester.defaultParams ListTester.run(new ArrayList&lt;Integer&gt;(), tests); ListTester.run(new LinkedList&lt;Integer&gt;(), tests); &#125;&#125;/*output--------------------- ArrayList --------------------- size add get set iteradd insert remove 10 286 29 35 203 45567 381 100 41 31 33 68 45739 118 1000 31 26 31 181 46414 21210000 15 30 28 1433 39079 1738--------------------- LinkedList --------------------- size add get set iteradd insert remove 10 311 64 65 209 516 289 100 32 84 90 19 206 44 1000 30 751 784 30 142 3310000 25 12406 12659 42 161 51*/ 可以看到，对于ArrayList，随机访问操作开销小，中间插入元素开销较大，对于LinkedList,恰恰相反。 Set的选择测试代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140package wangliang;import java.util.*;import org.omg.CORBA.PUBLIC_MEMBER;public class SetPerformance &#123; static List&lt;Test&lt;Set&lt;Integer&gt;&gt;&gt;list=new ArrayList&lt;Test&lt;Set&lt;Integer&gt;&gt;&gt;(); static&#123; list.add(new Test&lt;Set&lt;Integer&gt;&gt;(\"add\")&#123; int test(Set&lt;Integer&gt; list,TestParam tp)&#123; for(int i=0;i&lt;tp.loops;i++)&#123; list.clear(); for(int j=0;j&lt;tp.size;j++) list.add(j); &#125; return tp.loops*tp.size; &#125; &#125; ); list.add(new Test&lt;Set&lt;Integer&gt;&gt;(\"contains\")&#123; int test(Set&lt;Integer&gt; set,TestParam tp)&#123; int loop=tp.loops; int span=tp.size*2; for(int i=0;i&lt;loop;i++)&#123; for(int j=0;j&lt;span;j++) set.contains(j); &#125; return loop*span; &#125; &#125; ); list.add(new Test&lt;Set&lt;Integer&gt;&gt;(\"iterate\")&#123; int test(Set&lt;Integer&gt; set,TestParam tp)&#123; int loop=tp.loops*10; for(int i=0;i&lt;loop;i++)&#123; Iterator&lt;Integer&gt;it=set.iterator(); while(it.hasNext())&#123; it.next(); &#125; &#125; return loop; &#125; &#125; ); &#125; public static void main(String[] args)&#123; Tester.fieldWidth=10; Tester.run(new TreeSet&lt;Integer&gt;(), list); Tester.run(new HashSet&lt;Integer&gt;(), list); Tester.run(new LinkedHashSet&lt;Integer&gt;(), list); &#125;&#125;/*output------------- TreeSet ------------- size add contains iterate 10 801 444 855 100 176 64 1372 1000 130 120 921710000 167 152 99528------------- HashSet ------------- size add contains iterate 10 444 226 1507 100 54 11 2099 1000 42 15 1565210000 44 16 160976---------- LinkedHashSet ---------- size add contains iterate 10 443 131 3978 100 56 37 1799 1000 66 29 1513210000 53 31 155371*/ HashSet的性能总是比TreeSet好，除了需要排序的Set外，都用HashSet。 ###HashMap 容量：表中的桶位数。 初始容量：表在创建时所拥有的桶位数。HashMap和HashSet都具有允许你指定初始容量的构造器。 尺寸：表中当前存储的项数。 负载因子： 尺寸/容量。空表的负载因子是0,而半满表的负载因子是0.5,依次类推。负载轻的表产生的冲突的可能性小。因此对于插入和查找都是最理想的。可以人工指定负载因子，达到水平后扩大容量然后再散列。 Collection中的实用方法 max(Collection) 返回参数的Collection中最大或最小的元素，采用 min(Collection) Collection内置的自然比较法 max(Collection,Comparator) 同上，手动传入比较法。 min(Collection,Comparator) reverse(list) 逆转所有元素次序 reverseOrder() 返回一个Comparator,逆转顺序 reverseOrder(Comparator) shuffle(List) 随机顺序 shuffle(List,Random) sort(List) 排序 sort(List.Comparator&lt;?SuperT&gt;c) copy(Listdest,List&lt;?extends T&gt;src) 复制元素 swap(List,int i,int j) 交换两个位置元素，有优化 min()和max()只能作用于Collection对象。不用管排序。 WeakReference先说说Java中的GC，当一个对象object被创建时，它被放在Heap里。当GC运行的时候，如果发现没有任何引用指向object，object就会被回收以腾出内存空间。或者换句话说，一个对象被回收，必须满足两个条件：1)没有任何引用指向它 2)GC被运行. 当我们声明了一个强引用时，比如： StringBuilder buffer=new StringBuilder(); 这个buffer就是个强引用，当程序不可访问到这个对象时，也就是没有引用标识符引用它了，GC会自动回收这个对象，但是强引用在某些情况会出问题，比如我们用一个HashMap存了一个控件和空间对应的感兴趣值得映射，如果某个控件的值我们不需要了，就必须手动在HashMap里删除，否则这个值就一直不会释放。 解决方案就是WeakReference,可以用WeakHashMap来存储。就是类似于c++里面的weak_ptr。","tags":[{"name":"JAVASE","slug":"JAVASE","permalink":"http://yoursite.com/tags/JAVASE/"}]},{"title":"Java学习笔记8","date":"2017-12-28T12:05:09.000Z","path":"2017/12/28/Java学习笔记8/","text":"day9开始对容器的完整学习，几个常用容器是重点，无论是写算法题还是项目开发必备。 1.容器分类表首先，对JAVA中的容器进行总体上的把握，按照继承关系可看下图： 根据Oracle公司的官方文档： Collection是对Iterable接口的拓展。故所有的Collection对象都可以使用foreach方式，对元素进行方便的遍历。 由于Iterable接口中定义了的唯一方法为：返回一个Iterator对象，故所有的Collection都可以用 对象名.iterator()的方式获取该collection的迭代器iterator对象（结合工厂方法和内部类的思想来理解，其作用十分大） Map中提供了产生Collection的方法，以支持方便的对键值对的值域进行操作。 Collection&lt;V&gt; values() // Returns:a collection view of the values contained in this map. 从JAVA提供的数据容器来看，可以清晰的认识到面向对象的思想在类的架构设计中的重要性。 灵活的使用好各类容器类，以最大限度的提升程序的性能。由于类型过多，大多的基础操作都被抽象到了Collection中，熟练并利用好Collection提供的接口，已经可以解决大量的问题（即使是Map，其也提供了产生Collection对象的机制）。 Collection接口12345678910111213141516171819202122boolean add(Object o)//添加对象到集合boolean remove(Object o)//删除指定的对象int size()//返回当前集合中元素的数量boolean contains(Object o)//查找集合中是否有指定的对象boolean isEmpty()//判断集合是否为空Iterator iterator()//返回一个迭代器boolean containsAll(Collection c)//查找集合中是否有集合c中的元素boolean addAll(Collection c)//将集合c中所有的元素添加给该集合void clear()//删除集合中所有元素void removeAll(Collection c)//从集合中删除c集合中也有的元素void retainAll(Collection c)//从集合中删除集合c中不包含的元素 ListList主要将元素在特定的序列中，基本上在Collection的基础上加入了大量的方法，可以在List中间进行插入和删除 LinkedList LinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在 LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。 ArrayList类似于C++中的vector,随机访问元素快，中间插入删除慢，ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并 没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。和LinkedList一样，ArrayList也是非同步的（unsynchronized）。一般情况下使用这两个就可以了，因为非同步，所以效率比较高。如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。 Set接口Set是一种不包含重复的元素的Collection，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。 Set的构造函数有一个约束条件，传入的Collection参数不能包含重复的元素。Set容器类主要有HashSet和TreeSet等。 Java.util.HashSet类实现了Java.util.Set接口。 HashSet 它不允许出现重复元素； 不保证和政集合中元素的顺序 允许包含值为null的元素，但最多只能有一个null元素。 1234567891011121314151617181920212223242526272829303132333435363738public static void main(String [] args) &#123; HashSet h=new HashSet(); h.add(1st); h.add(2nd); h.add(new Integer(3)); h.add(new Double(4.0)); h.add(2nd); //重复元素，未被添加 h.add(new Integer(3)); //重复元素，未被添加,对象的重复判定规则是.equals(). h.add(new Date()); Iterator it=h.iterator(); while(it.hasNext()) &#123; Object o=it.next(); System.out.println(o); &#125; h.remove(2nd); System.out.println(h); TreeSetTreeSet描述的是Set的一种变体——可以实现排序等功能的集合，它在讲对象元素添加到集合中时会自动按照某种比较规则将其插入到有序的对象序列中，并保证该集合元素按照“升序”排列。 MapHashMapHashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value null key，但是将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap的容量成比例。因此，如果迭代操作的性能相当重要的话，不要将HashMap的初始化容量设得过高，或者load factor过低。 －JDK1.0引入了第一个关联的集合类HashTable，它是线程安全的。 HashTable的所有方法都是同步的。 －JDK2.0引入了HashMap，它提供了一个不同步的基类和一个同步的包装器synchronizedMap。synchronizedMap被称为 有条件的线程安全类。 －JDK5.0util.concurrent包中引入对Map线程安全的实现ConcurrentHashMap，比起synchronizedMap， 它提供了更高的灵活性。同时进行的读和写操作都可以并发地进行。 Iterator我们在使用Iterator时一般可以这样用： 123456789101112131415161718192021222324List&lt;Apple&gt; apples=new ArrayList&lt;Apple&gt;();//...//遍历Iterator&lt;Apple&gt; it=apples.iterator();while(it.hasNext())&#123; System.out.println(it.next());&#125;//删除while(it.hasNext())&#123; it.next(); it.remove();&#125; 接下来看一下源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788private class Itr implements Iterator&lt;E&gt; &#123; int cursor = 0; // 下一个next元素的位置 int lastRet = -1; //最后访问的位置 int expectedModCount = modCount; //fast-failed机制，可以在多线程中防止其他线程在这个迭代器使用过程中修改容器结构。 public boolean hasNext() &#123; return cursor != size(); &#125; public E next() &#123; checkForComodification(); try &#123; int i = cursor; E next = get(i); lastRet = i; cursor = i + 1; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException e) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; 一般而言，迭代器是实现了Iterator接口，有三个方法： Next() hasNext() remove() 2.填充容器Collections.fill()可以填充List对象，只能复制同一对象。 Collections.nCopy()可以复制对一个对象的多个引用。 Set Set(interface) 存入Set的每个元素是不同的，也就是.equals()要返回false，Set与Collection有相同的接口 HashSet,存放的元素必须有hashCode()方法。 TreeSet,存放元素有序。 LinkedHashSet,具有HashSet的查询速度，按照插入的次序排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142package wangliang;import java.security.cert.TrustAnchor;import java.util.HashSet;import java.util.Hashtable;import java.util.LinkedHashSet;import java.util.Objects;import java.util.Set;import java.util.TreeSet;class SetType&#123; int i; public SetType(int n)&#123; i=n; &#125; public boolean equals(Object o)&#123; return o instanceof SetType &amp;&amp;(i==((SetType)o).i); &#125; public String toString()&#123; return Integer.toString(i); &#125;&#125;class HashType extends SetType&#123; public HashType(int n)&#123; super(n); &#125; public int hashCode()&#123;return i;&#125;&#125;class TreeType extends SetTypeimplements Comparable&lt;TreeType&gt;&#123; public TreeType(int n)&#123;super(n);&#125; public int compareTo(TreeType o)&#123; return (this.i&lt;o.i)?-1:((this.i==o.i)?0:1); &#125;&#125;public class TypesForSets &#123; static &lt;T&gt; Set&lt;T&gt; fill(Set&lt;T&gt; set,Class&lt;T&gt; type)&#123; try&#123; for(int i=0;i&lt;10;i++)&#123; set.add(type.getConstructor(int.class).newInstance(i)); &#125; &#125;catch (Exception e) &#123; throw new RuntimeException(e);// TODO: handle exception &#125; return set; &#125; static &lt;T&gt; void test(Set&lt;T&gt; set,Class&lt;T&gt; type)&#123; for(int i=0;i&lt;3;i++) fill(set, type); System.out.println(set); &#125; public static void main(String[] args)&#123; test(new HashSet&lt;HashType&gt;(),HashType.class); test(new LinkedHashSet&lt;HashType&gt;(),HashType.class); test(new TreeSet&lt;TreeType&gt;(),TreeType.class); test(new HashSet&lt;SetType&gt;(), SetType.class); try&#123; test(new TreeSet&lt;SetType&gt;(),SetType.class ); &#125;catch (Exception e) &#123; System.out.println(e.getMessage());// TODO: handle exception &#125; &#125;&#125;//output/*[0, 1, 2, 3, 4, 5, 6, 7, 8, 9][0, 1, 2, 3, 4, 5, 6, 7, 8, 9][0, 1, 2, 3, 4, 5, 6, 7, 8, 9][5, 8, 1, 7, 3, 7, 9, 1, 9, 6, 7, 8, 4, 0, 3, 4, 9, 3, 2, 0, 5, 2, 1, 6, 6, 5, 4, 2, 8, 0]java.lang.ClassCastException: wangliang.SetType cannot be cast to java.lang.Comparable*/ 可以看到，如果没有实现hashCode()方法的类放入HashSet中，会出现无法估计的结果。","tags":[{"name":"JAVASE","slug":"JAVASE","permalink":"http://yoursite.com/tags/JAVASE/"}]},{"title":"Java学习笔记7","date":"2017-12-28T12:03:56.000Z","path":"2017/12/28/Java学习笔记7/","text":"day81.使用泛型出现的问题任何基本类型都不能作为类型参数因此，不能创建类如ArrayList之类的东西，解决方法是使用基本类型的包装器类和自动包装机制，如果创建一个ArrayList,可以自动实现int到Integer的双向转换。 1234567891011121314151617181920public class ListOfInt&#123; public static void main(String[] args)&#123; List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); for(int i=0;i&lt;5;i++)&#123; list.add(i); &#125; for(int i:li) System.out.println(i+\" \"); &#125;&#125;//output 0 1 2 3 4 但是，自动包装机制不能运用于数组 参数化接口一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，会让两个变体都变成相同的接口，比如： 12345678910interface Fruits&lt;T&gt;&#123;&#125;class Apple implements Fruits&lt;String&gt;&#123;&#125;class RedApple extends Appleimplements Fruits&lt;Integer&gt;&#123;&#125; 上述RedApple无法编译，因为两次实现了Fruits。 2.数组数组的优点：比ArrayList的效率高，访问速度快。在没有泛型之前，所有容器的持有对象都视为Object，而数组可以维持某个具体对象的序列。数组可以使用[]来访问元素。 应用：一般情况下优先使用容器，功能更多，特殊情况对效率有要求可用数组。 数组标识符本身也是一个对象引用，指向堆中一个保存指向其他对象引用的数组。 12345678910Apple[] a;//未初始化Apple[] a=new Apple[10];//指向堆上一个长度为10的Apple数组，但数组内元素(引用)全被初始化null。a.length为数组长度10，而不是实际元素个数。Apple[] a=&#123;new apple(),new apple(),new apple()&#125;;//隐式在堆上创建数组对象。只能定义时这么做。a=new Apple[10]&#123;new...&#125;;可以任何时候这么做。Apple[] b=a;//a和b都指向堆上同一个数组。 多维数组： 123456int [][] a=&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;;int [][][]a=new int[2][2][3];System.out.println(Arrays.deepToString(a));//这个方法可以打印多维数组。 另外，数组对泛型不支持，下面这种声明错误： 123456789101112131415161718192021222324Apple&lt;String&gt;[] a=new Apple&lt;String&gt;[10];//擦除使得数组不确定所含对象的类型，必须知道切确类型。不推荐使用数组，可以用ArrayList代替。### Arrays中一些API六个static方法用与数组：- `equals()`比较两个数组是否相等- `fill()`填充数组。- `sort()`排序- `binarySearch()'二分查找- `toString()`用String表示- `hashCode()`产生数组的散列码### 数组的复制我们可以通过for循环来复制数组，比如： Apple[]a={new Apple(),new Fruit()}; Apple[]b=new Apple[a.length]; for(int i=0;i&lt;a.length;i++){ b[i]=a[i]; } ``` 有一个方法System.arraycopy()可以用来复制数组比for循环要快。 数组比较，排序只要类中实现了Comparable接口，java.lang.Comparable,就可以排序，接口只含有一个方法compareTo(),类似于c++中重载比较操作符。 也可以自己定义一个实现Comparator接口的类，有compare()和equals()两个方法，只要事先compare()就可以了。 Collections.reverseOrder()可以产生一个Comparator用来逆序sort。","tags":[{"name":"JAVASE","slug":"JAVASE","permalink":"http://yoursite.com/tags/JAVASE/"}]},{"title":"Java学习笔记6","date":"2017-12-28T12:00:45.000Z","path":"2017/12/28/Java学习笔记6/","text":"day71.泛型与c++泛型的第一个区别是，java泛型的参数T不能为基本数据类型，如果是int编译器自动推导成Integer。 泛型第一个应用就是可以创造生成器，工厂模式的一个应用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public interface Generator&lt;T&gt;&#123; T next();//一般一个生成器就定义一个方法用来获取对象。package wangliang;import java.util.*;interface Generator&lt;T&gt;&#123;//生成器，定义一个方法next()用来获得对象。 public T next();&#125;class Coffee&#123;&#125;class Latte extends Coffee&#123;&#125;class Mocha extends Coffee&#123;&#125;public class CoffeeGenerator implements Generator&lt;Coffee&gt;,Iterable&lt;Coffee&gt;&#123; private int size=0; List&lt;Class&gt; types=Arrays.asList(Latte.class,Mocha.class); private static Random rand=new Random(47); CoffeeGenerator(int sz)&#123; this.size=sz; &#125; public Coffee next()&#123; try&#123; return (Coffee)types.get(rand.nextInt(types.size())).newInstance(); &#125;catch (Exception e) &#123; throw new RuntimeException(e); // TODO: handle exception &#125; &#125; public Iterator&lt;Coffee&gt; iterator()&#123; return new Iterator&lt;Coffee&gt;()&#123; private int count=CoffeeGenerator.this.size; public Coffee next()&#123; count--; return CoffeeGenerator.this.next(); &#125; public boolean hasNext()&#123; return count&gt;0; &#125; public void remove()&#123; &#125; &#125;; &#125; public static void main(String[] args)&#123; &#125;&#125; 对于模板方法的定义与c++不同，要在返回值的后面加上模板参数： 12public &lt;T&gt; void f(T x)&#123;&#125; 2.Iterator与Iterablejava.lang.Iterable是一个接口interface，一般用来实现这个接口可用于iterator()方法。这个接口也是我们自己设计类时常实现的接口，我们不直接实现Iterator，而是实现Iterable。 为什么这样做呢？ 因为Iterator接口的核心方法next()或者hasNext() 是依赖于迭代器的当前迭代位置的。 如果Collection直接实现Iterator接口，势必导致集合对象中包含当前迭代位置的数据(指针)。 当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么next()方法的结果会变成不可预知。 除非再为Iterator接口添加一个reset()方法，用来重置当前迭代位置。 但即时这样，Collection也只能同时存在一个当前迭代位置。 而Iterable则不然，每次调用都会返回一个从头开始计数的迭代器。 多个迭代器是互不干扰的。 123456789101112131415161718192021222324package java.lang;public interface Iterable&lt;AnyType&gt;&#123;Iterator&lt;AnyType&gt; iterator();&#125;packge java.util;public interface Iterator&lt;AnyType&gt;&#123; boolean hasNext(); AnyType next(); void remove();//三个接口&#125; 3.运用于匿名内部类12345678910111213141516171819202122class Customer&#123; private static long counter=1; private final long id=counter++; private Customer()&#123;&#125; public String toString()&#123;return \"Customer \"+id;&#125; public static Generator&lt;Customer&gt; generator()&#123; return new Generator&lt;Customer&gt;()&#123; public Customer next()&#123;return new Customer();&#125; &#125;; &#125;&#125; 可以看到，Customer类中的generator方法有了static修饰，不能用继承接口Generator实现方法。可以通过泛型来做到这点。 4.擦除什么是擦除？ 我们可以声明ArrayList.class,但是不能调用ArrayList.class，看下面的代码： 1234567891011121314151617181920import java.util.*; public class ErasedTypeEquivalence &#123; public static void main(String[] args) &#123; Class c1 = new ArrayList&lt;String&gt;().getClass(); Class c2 = new ArrayList&lt;Integer&gt;().getClass(); System.out.println(c1 == c2); &#125; &#125;/* Output: true *///:~ 两个我们看来不同的类型ArrayList和ArrayList的Class却是相同的。再看下面： 12345678910111213141516171819202122232425262728293031323334public class HasF &#123; public void f() &#123; System.out.println(\"HasF.f()\"); &#125; &#125; class Manipulator&lt;T&gt; &#123; private T obj; public Manipulator(T x) &#123; obj = x; &#125; // Error: cannot find symbol: method f(): public void manipulate() &#123; obj.f(); &#125; &#125;public class Manipulation &#123; public static void main(String[] args) &#123; HasF hf = new HasF(); Manipulator&lt;HasF&gt; manipulator = new Manipulator&lt;HasF&gt;(hf); manipulator.manipulate(); &#125; &#125; /// 上述代码会报错，原因是Java运用了擦除，就是说在泛型代码运行时是将类型T擦掉的，一直向上替换到边界，没指定上边界就会换到Object.比如说上例中obj就无法调用.f()。简而言之： 在泛型代码内部，无法获得任何泛型参数类型的信息 我们需要通过边界来让他接受这个类型是有这个调用方法的。 在泛型参数T后加上extends HasF,表示这个参数是HasF的类型或者子类，这样就肯定有.f()方法。 另，在泛型中不要创建数组，例如T[]最好用ArrayList代替，如果需要推荐用Array.newInstance(kind,size). 5.边界语法定义： T extends classA&amp;interfaceB&amp;interfaceC&amp;…//一定要按照这种顺序写 6.运用通配符我们在表示两个List,List时，虽然Cat继承自Animal，但这两个类型没有继承关系，因此通过通配符达到这种效果： 如果B是A的子类，那么List&lt;? extends B&gt;是List&lt;? extends A&gt;的子类","tags":[{"name":"JAVASE","slug":"JAVASE","permalink":"http://yoursite.com/tags/JAVASE/"}]},{"title":"Java学习笔记5","date":"2017-12-17T17:43:15.000Z","path":"2017/12/18/Java学习笔记5/","text":"day51.RTTI在运用多态时才有意义。每个类都有个Class对象用来判断自己的RTTI。 类加载器所有的类在第一次加载时，也就是第一次调用类的静态成员，例如构造器，就会加载到JVM中。 加载器会查找类的.class文件，然后Class对象被加载到内存后，用来构建这个类的所有对象。 Class类的接口forName(String class)来取得一个类的对象的引用。 123456789101112public class Test&#123;&#125;Class cc=Class.forName(\"Test\");cc.getname();cc.isinterface();cc.getSuperclass();cc.newInstance();返回一个该类的对象，需要有default constructor。 还可以通过类字面量来得到一个类的Class，这适用于所有基本数据类型。 int.class,double.class,void.class 用.class调用不会对一个未初始化的类初始化，另外，static final变量不需要初始化就可以调用。比如：123456789101112131415161718192021public class Test&#123; static final int LENGTH=10; static&#123; System.out.println(\"constructor\"); &#125;//静态域第一次初始化会调用&#125;public class Main&#123; public static void main()&#123; System.out.println(Test.LENGTH);//没有constructor打印 &#125;&#125; java中的通配符是？。 RTTI的形式： 我们用RTTI是为了对于一个接口或者基类，需要向下转换时，我们无法知道他是子类中的哪种。 传统类型转换，(Class)object. 通过instanceof，调用为 class instanceof target，这个表达式返回一个boolean，判断一个类是否是目标类，如果是的话可以强制向下转换。或者Class.isInstance(),可以不用写多个instanceof()。 2.反射定义：RTTI的限制在于，要识别的对象类型必须在编译阶段已知，如果对象类型的.class文件在网络或者本地磁盘上，需要动态加载。","tags":[]},{"title":"Java学习笔记4","date":"2017-12-17T17:42:46.000Z","path":"2017/12/18/Java学习笔记4/","text":"1.StringBuilder我们在用+号相加两个String类时，JVM会创建一个StringBuilder类，然后将所有相加的String类全都append()，最后toString()返回最后结果。以下两段代码： 1234567891011121314151617181920212223242526272829303132public static StringBuilder&#123; public implicit(String[] fields)&#123; String s=\"\"; for(int i=0;i&lt;fields.length;i++)&#123; s+=fields[i]; &#125; return s; &#125; public explicit(String[] fields)&#123; StringBuilder s=new StringBuilder(); for(int i=0;i&lt;fields.length;i++)&#123; s.append(fields[i]); &#125; return s.toString(); &#125;&#125; 第一个implicit方法中，每次循环都要创建一个StringBuilder类，而第二个只要创建一次。更优化的方法还可以先指定StringBuilder的大小，避免多次重新分配。 注意：给一个类定义toString()接口时，如果内部有隐式调用本身的toString()，会发生无限递归。 12345678public class Recurrsion&#123; String toString()&#123; //return \"recurrsion address: \"+this;//+号隐式转换发生递归调用自己。 return \"recurrsion address： \"+super.toString();//正确做法，基类是Object。 2.内部类的static内部类用static修饰，有两个作用： 没有this，无法取得外部类的this。 调用时可以直接调用无需new，例如： 12345678910111213141516public class Test&#123; public static InnerA&#123;&#125; private InnerB&#123;&#125; public static void main(String[] args)&#123; new Test.InnerA(); new Test().new InnerB();//区别。&#125; 3.格式化输出System.out.format()方法模仿了c的printf()，用法一样。 新的接口： Formatter类是Java中用来处理格式化输出的类，构造器需要一个想哪里输出的流。 类中format()接口用来输出，格式： %[argument_index][flag][width][.precision]conversion %-10.5f:-表示左对齐，10表示宽度，.5精度，用来String上表示显示字符数量。f是float。 String.format()一个static方法，接受一个格式串。 3.正则贪婪：意味着最大匹配，匹配最大长度。 懒惰： 最小匹配，匹配满足的最小长度。 比如”aaaa”中用贪婪匹配能匹配”aaaa”，用？懒惰匹配就匹配”a” 元字符 ^:匹配行或者字符串的起始位置。 $:匹配行或者字符串的结尾。 \\b:匹配一个位置，不消耗任何字符。 \\d:匹配一个数字。 \\w:匹配字母，数字，下划线。 \\s:匹配空格。 .:匹配一个除了换行符以外所有字符。 [abc]:匹配一个括号内的字符。 反义字符改成大写就行 [^abc]:除了abc以外的字符。 \\W:不是字母，数字，下划线的字符。 量词 *:匹配前面的一个闭包。贪婪的 +:与*相同，唯一区别是不可以0次匹配。懒惰的 [:标记一个中括号表达式的开始。 ?:匹配前面的子表达式0或1次。可以指明一个非贪婪限定符。 {:标记限定符表达式的开始。 |:两个表达式或匹配。 {n}:匹配确定的n次 {n,}:至少匹配n次。 {n,m}:匹配n-m次。 String中匹配正则的接口是matches(String format) 更高级的工具是Pattern和Matcher. Pattern通过static方法compile(String)编译一个正则，返回一个Matcher，Matcher有接口matcher(String)用来匹配字符串。还有接口group(),find(),","tags":[]},{"title":"Java学习笔记3","date":"2017-12-17T17:41:14.000Z","path":"2017/12/18/Java学习笔记3/","text":"day31.Iterable继承这个接口就可以用foreach语法作用。 数组不能转换成Iterable，要 2.Map补充Map中有接口 KeySet() entrySet()//返回k-v对的集合 Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为Entry。它表示Map中的一个实体（一个key-value对）。接口中有getKey(),getValue方法。 标准Map访问方法： 123456789101112131415161718Set keys = map.keySet( );if(keys != null) &#123;Iterator iterator = keys.iterator( );while(iterator.hasNext( )) &#123;Object key = iterator.next( );Object value = map.get(key);;....;&#125;&#125; 用entrySet()接口方法： 1234567891011121314151617181920Set entries = map.entrySet( );if(entries != null) &#123;Iterator iterator = entries.iterator( );while(iterator.hasNext( )) &#123;Map.Entry entry =iterator.next( );Object key = entry.getKey( );Object value = entry.getValue();;....&#125;&#125; 可以看到，每次迭代器都能直接得到K和V，不用向上面的方法迭代得到key,然后得到Value。 3.匿名内部类有时候我们在创建一个继承了某个接口或者父类的对象时，可以在创建同时定义： 匿名内部类也就是没有名字的内部类 正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写 但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口 实例1:不使用匿名内部类来实现抽象方法 1234567891011121314151617181920212223242526272829303132abstract class Person &#123; public abstract void eat();&#125;class Child extends Person &#123; public void eat() &#123; System.out.println(\"eat something\"); &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; Person p = new Child(); p.eat(); &#125;&#125; 运行结果：eat something 可以看到，我们用Child继承了Person类，然后实现了Child的一个实例，将其向上转型为Person类的引用 但是，如果此处的Child类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？ 这个时候就引入了匿名内部类 实例2：匿名内部类的基本实现 12345678910111213141516171819202122232425262728abstract class Person &#123; public abstract void eat();&#125;public class Demo &#123; public static void main(String[] args) &#123; Person p = new Person() &#123; public void eat() &#123; System.out.println(\"eat something\"); &#125; &#125;; p.eat(); &#125;&#125; 运行结果：eat something 可以看到，我们直接将抽象类Person中的方法在大括号中实现了 这样便可以省略一个类的书写 并且，匿名内部类还能用于接口上 实例3：在接口上使用匿名内部类 12345678910111213141516171819202122232425262728interface Person &#123; public void eat();&#125;public class Demo &#123; public static void main(String[] args) &#123; Person p = new Person() &#123; public void eat() &#123; System.out.println(\"eat something\"); &#125; &#125;; p.eat(); &#125;&#125; 运行结果：eat something 由上面的例子可以看出，只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现 最常用的情况就是在多线程的实现上，因为要实现多线程必须继承Thread类或是继承Runnable接口 实例4：Thread类的匿名内部类实现 123456789101112131415161718192021222324public class Demo &#123; public static void main(String[] args) &#123; Thread t = new Thread() &#123; public void run() &#123; for (int i = 1; i &lt;= 5; i++) &#123; System.out.print(i + \" \"); &#125; &#125; &#125;; t.start(); &#125;&#125; 运行结果：1 2 3 4 5 实例5：Runnable接口的匿名内部类实现 1234567891011121314151617181920212223242526public class Demo &#123; public static void main(String[] args) &#123; Runnable r = new Runnable() &#123; public void run() &#123; for (int i = 1; i &lt;= 5; i++) &#123; System.out.print(i + \" \"); &#125; &#125; &#125;; Thread t = new Thread(r); t.start(); &#125;&#125; 运行结果：1 2 3 4 5 4.容器补充容器不能拥有基本类型，比如List就是错误的。 5.异常在需要抛出异常的方法声明最后加上throws exceptionType 抛出的异常都是在堆上new出来的异常对象。抛出他的引用。 printStackTrace()方法可以打印抛出异常的调用序列。","tags":[]},{"title":"Java学习笔记2","date":"2017-12-17T17:40:14.000Z","path":"2017/12/18/Java学习笔记2/","text":"day21.abstract关键字抽象类中有若干个抽象方法，类和方法都要用abstract修饰。 interface则不用实现任何方法，纯接口，如果有类来实现他，要用implements而不是extends 2.适配器模式给一个类做一个适配器类，让这个类的接口可以任意指定。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 // 适配器类，直接关联被适配类，同时实现标准接口class Adapter implements Target&#123; // 直接关联被适配类 private Adaptee adaptee; // 可以通过构造函数传入具体需要适配的被适配类对象 public Adapter (Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; public void request() &#123; // 这里是使用委托的方式完成特殊功能 this.adaptee.specificRequest(); &#125;&#125;// 测试类public class Client &#123; public static void main(String[] args) &#123; // 使用普通功能类 Target concreteTarget = new ConcreteTarget(); concreteTarget.request(); // 使用特殊功能类，即适配类， // 需要先创建一个被适配类的对象作为参数 Target adapter = new Adapter(new Adaptee()); adapter.request(); &#125;&#125; 可以看到，适配器模式用来将一个不符合我们要求的接口的类包装一下，成为一个符合我们接口的类。 3.接口内接口内定义的成员变量都是默认public static final修饰。静态常量。接口的所有成员都是public 4.多重继承只能继承一个具体的类，可以继承任意多个接口。 5.内部类内部类如果是非static类，就可以访问到外围类的对象成员，因为外围类对象在创建内部类对象时，内部类对象会捕获一个外围类对象的引用，进而可以访问。 在内部类可以调用outerclassname.this来调用外部类的引用。 还可以用outerclassname.new 来生成一个内部对象。 protected权限包内类可访问。 6.ArrayList类似于c++的vector，当作一个变长数组，不同的是，声明时可以不用声明所含数据类型。 12a=new ArrayList(); 不能用[]访问，要用get(int id)方法访问。 两种容器类型Collection和Map,他们本身就是一个基类。 7.List分为ArrayList和LinkedList,相当于c++的vector和List。 List的常用接口 get(index) indexOf(obj) remove(obj)//删除引用的对象 add(obj) add(index,obj)//插入 subList(start,end) sort(List) contains（obj)//查询 asList((args…))//包装成一个List返回 set(index,obj) equals() shuffle()//洗牌 replace()//同set() LinkedList还有： add(),addLast() addFirst() peek() 8.迭代器接口原理和c++一样。 iterator()//返回一个迭代器，通过next()返回元素。 next()//返回下一个元素 hasNext()//是否还有 remove()//删除最近next的元素 Iterator只能向前移动，子类ListIterator可以双向移动。 9.Queue同c++的queue，接口是： offer()//插入队尾 10.Map同c++的Map，接口： put（a,b)//插入 11.pollpoll弹出并删除首个元素，pop仅查看。 12.Collection和Iterator可以同时实现Collection参数的方法，这样可以运用到所有子类中。 也可以实现迭代器版本，达到同样效果。迭代器版本不局限于Collection的子类。","tags":[]},{"title":"Java学习笔记1","date":"2017-12-17T17:37:58.000Z","path":"2017/12/18/Java学习笔记1/","text":"从今天开始学习java，写一个java学习系列笔记，做好每一个比较重要和难懂的知识点。 day11.staticstatic关键字用法和c++基本相同，不过可以作用于一个域，比如: 12345678910pulbic class Test&#123;static&#123;//... &#125;&#125; static不能作用于局部变量，可以作用于类的接口，成员变量，类。 2.一切皆对象所有对象需要用new，new出来的对象存在堆中，对象的变量都是对象的引用，不需要手动释放，有垃圾回收 123456789101112131415161718public class Test&#123;void f()&#123;a=new Test();new Test().d();//直接调用&#125;static void d()&#123;System.out.println(\"d\");&#125;&#125; 3.数组12345678910111213141516int[] a1;//Java写法，不允许指定数组大小int a2[];//c写法a1=&#123;1,1&#125;;a2=a1;//复制引用,共同引用一个堆上对象Integer[] a3=new Integer[10];//此时a3是一个数组，所有元素都是引用。引用的对象没有初始化。for(int i=0;i&lt;a.length;i++)&#123;a3[i]=0;&#125;//完成初始化 4.对象和对象引用new A()是一个对象，A a=new A()中a只是一个引用，翻译叫标识符。 5.enumenum也是一个对象 12345678public enum S&#123;HAHA,SB,HEHE&#125;S s=S.HAHA; enum类型自动添加一些接口，例如toString(),values(),ordinal() 6.package使用方法 import ..* 作用避免重名，类似c++namespace，每个.java只能有一个public类，而且与文件名同名。 每个类都会产生一个.class文件，java通过解释器作用于一堆.class文件。 一个源文件属于一个包，一个包中的文件应当在一个子目录下。 一个子目录下的所有文件中的类默认一个包。 7.访问权限类的一个接口如果没有public，只有包内的类可以访问。","tags":[]},{"title":"muduo网络库简介","date":"2017-09-23T13:21:19.000Z","path":"2017/09/23/muduo网络库简介/","text":"muduo/basemuduo/base 目录是一些基础库,都是用户可见的类,内容包括: –base/ Asynclogging.{h,cc} 异步日志backend Atomic.h 原子操作 BLockingQueue.h 无界阻塞队列 BoundBLockingQueue.h 有界阻塞队列 Condition.h 条件变量,与Mutex.h一同使用 CountDownLatch.{h,cc} Threadpool. {h,cc} 简单的线程池大小 threadlocal.h 线程局部数据 THread.{h,cc} 线程对象 doc muduo/net–net/ acceptor.{h,cc} 接收器,用于服务端接受连接 Buffer.{h,cc} 缓冲区,非阻塞IO必备 Callbacks.h endian.h 网络字节序和主机字节序转换 EventLoop.{h,cc} 事件分发器 eventLoopThread.{h,cc} 新建一个专门用于EventLoop的线程 EventLoopThreadPool.{h,cc} muduo默认多线程IO模型 TcpConnection.{h,cc} doc 线程模型one loop per thread + threadpool threadpool 分两种,一种用来计算,一种用来做io线程. eventloop这个类用来调用poll或者epoll_wait,用于监听事件,然后调用每个描述符的channel channelchannel 是Reactor关键结构,每个channel对应一个fd,只属于一个IO线程,负责这个fd 的事件分发,可以给这个fd的读写事件注册回调函数. poller##","tags":[{"name":"muduo","slug":"muduo","permalink":"http://yoursite.com/tags/muduo/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"服务器开发测试常用命令和工具","date":"2017-09-22T08:45:49.000Z","path":"2017/09/22/服务器开发测试常用命令和工具/","text":"gdblinux 下首先会用的就是gdb,关于gdb我们分单独一篇来写 tcpdumpnetstatifconfigisoftop","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"sockets","slug":"sockets","permalink":"http://yoursite.com/tags/sockets/"}]},{"title":"shared_ptr和weak_ptr","date":"2017-09-22T00:53:09.000Z","path":"2017/09/22/shared-ptr和weak-ptr/","text":"shared_ptr线程安全性 shared_ptr 本身不是 100% 线程安全的。它的引用计数本身是安全且无锁的，但对象的读写则不是，因为 shared_ptr 有两个数据成员，读写操作不能原子化。根据文档，shared_ptr 的线程安全级别和内建类型、标准库容器、string 一样，即： 一个 shared_ptr 实体可被多个线程同时读取； 两个的 shared_ptr 实体可以被两个线程同时写入，“析构”算写操作； 要从多个线程读写同一个 shared_ptr 对象，那么需要加锁。 用法12345678shared_ptr&lt;int&gt; sp(new int(10)); //一个指向整数的shared_ptr assert(sp.unique()); //现在shared_ptr是指针的唯一持有者 shared_ptr&lt;int&gt; sp2 = sp; //第二个shared_ptr,拷贝构造函数 assert(sp == sp2 &amp;&amp; sp.use_count() == 2); //两个shared_ptr相等,指向同一个对象,引用计数为2 *sp2 = 100; //使用解引用操作符修改被指对象 assert(*sp == 100); //另一个shared_ptr也同时被修改 sp.reset(); //停止shared_ptr的使用 assert(!sp); //sp不再持有任何指针(空指针) 提示:shared_ptr可作为容器的元素,重载了比较和拷贝操作符,auto_ptr不可以 使用陷阱意外延长声明周期 shared_ptr是强引用,只要有一个指向对象的shared_ptr存在,该对象就不会析构. 要注意bind函数,bind会把实参拷贝一份,意外延长对象生命周期 函数参数 我们用const引用来传递类型为shared_ptr的函数参数 析构所在的线程 对象的析构是同步的,当最后一个指向x的shared_ptr离开其作用域的时候,x会同时在同一个线程析构,这个线程不一定是对象诞生的线程,如果析构比较耗时,并且在关键线程中析构,那么会拖累线程的速度, 解决办法是我们可以单独开一个线程专门用来析构,通过一个BlockingQueue","tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"stl","slug":"stl","permalink":"http://yoursite.com/tags/stl/"}]},{"title":"服务器项目关键组件","date":"2017-08-31T01:52:28.000Z","path":"2017/08/31/服务器项目关键组件/","text":"定时器话说网络程序通常需要处理的三类事件:第一是IO事件,第二是信号,第三就是定时事件,比如定期检测一个客户连接的状态,定时指的是一段时间后触发某段代码的机制.为了实现一个定时器容器,我们选择用链表来实现,可按触发时间来排序存储,每个节点都是一个定时器,储存着: 触发时间和触发事件 所处理的对象 上一个和下一个定时器的位置 再设计一个脉搏函数,每次间隔最小时间后就调用,然后将容器中所有到时的定时器触发. 时间轮如果按上述方式实现定时器,则插入的时间为O(n),效率随着定时器增加而降低,所以我们根据哈希的思想,用空间换时间,改用时间轮的方法.用两个轮,小轮走一圈,大轮走一格,每个槽上都有一个链表,存储时间是该轮整数倍的定时器. 实现代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139//实现一个时间轮定时器,按超时时间排一圈,每个刻度上都有一个链表,存储所有#include&lt;time.h&gt;#include&lt;net_h.h&gt;#include&lt;algorithm&gt;#define BUFFER_SIZE 64class tw_timer;//用户数据结构,客户端地址,socket文件描述符,读缓冲区和定时器struct client_data&#123; sockaddr_in address; int sockfd; char buf[BUFFER_SIZE]; tw_timer* timer;&#125;;class tw_timer&#123;public: tw_timer():rotation(-1),time_slot(-1),prev(nullptr),next(nullptr)&#123;&#125; //tw_timer(tw_timer&amp;); tw_timer(int ro,int ts):rotation(ro),time_slot(ts),prev(nullptr),next(nullptr)&#123;&#125;private: //时间轮转多少圈后生效 int rotation; //属于哪个槽 int time_slot; void (*cb_func)(client_data*); client_data* user_data; tw_timer* prev; tw_timer* next;&#125;;class tw_wheels&#123;public: tw_wheels():curr_slot(-1)&#123; fill_n(this-&gt;wheel,nullptr,sizeof(wheel)); &#125; ~tw_wheels();// void addtimer(tw_timer&amp;); void addtimer(tw_timer* ,tw_timer* ); void del_timer(tw_timer*); void work(int ,int);//让某一个槽上的所有定时器工作 void set_timer(tw_timer,int time_slot,int rotation); void tick();private: //void addtimer(tw_timer* head,); //释放一条链表上的定时器 void release(tw_timer*); static const int K=2;//多少轮子 static const int N=60;//每个轮子多少个槽 static const int SI=1;//最底层轮子的槽间隔为1s tw_timer* wheels[K][N]; int curr_slots[K];//当前指向的槽&#125;;tw_wheels::~tw_wheels()&#123; for(int i=0;i&lt;K;i++)&#123; for(int j=0;j&lt;N;j++) this-&gt;release(wheels[i][j]); wheels[i][j]=nullptr; &#125;&#125;void tw_wheel::release(tw_timer* head)&#123; if(head==nullptr)return; while(head)&#123; tw_timer* temp=head-&gt;next; del_timer(head); head=temp; &#125;&#125;void tw_wheels::addtimer(int timeout,void(*func)(client_data*))&#123; int rot=0,ts=0,i; for( i=K-1;i&gt;=0;i--)&#123; if(timeout+curr_slots[0])%pow(N,i)==0)&#123; int time=(timeout/pow(N,i)); rot=time/N; ts=(time+this-&gt;curr_slots[i])%N; break; &#125; &#125; tw_timer* new_timer=new tw_timer(rot,ts); new_timer-&gt;cb_run=func; addtimer(i,new_timer);&#125;void tw_wheels::addtimer(int wheelsize,tw_timer* target)&#123; int slotpos=target-&gt;time_slot; if(wheels[wheelsize][slotpos]==nullptr)&#123; wheels[wheelsize][slotpos]=target; &#125;else&#123; tw_timer* p=wheels[wheelsize][slotpos]; wheels[wheelsize][slotpos]=target; target-&gt;next=p; p-&gt;prev=target; &#125;&#125;void tw_wheels::del_timer(tw_timer* obj)&#123; if(obj==nullptr)return; if(obj-&gt;prev)&#123; obj-&gt;prev-&gt;next=obj-&gt;next; &#125; if(obj-&gt;next)&#123; obj-&gt;next-&gt;prev=obj-&gt;prev; &#125; delete obj;&#125;void tw_wheels::tick()&#123; int count=1; for(int i=0;i&lt;K;i++)&#123; if(count&gt;0)&#123; curr_slots[i]=(curr_slots[i]+count)%N; work(i,curr_slots[i]); &#125; count=(curr_slots[i])/N; &#125;&#125;void tw_wheels::work(int wheelsize,int slotpos)&#123; tw_timer* cur=wheels[wheelsize][slotpos]; while(cur)&#123; if(cur-&gt;rotation==0)&#123; cur-&gt;cb_func(cur-&gt;user_data); tw_timer* p=cur; cur=cur-&gt;next; del_timer(p); &#125;else&#123; cur-&gt;rotation--; cur=cur-&gt;next; &#125; &#125;&#125; 除了时间轮之外,还有的实现方法为时间堆. 信号量信号量是用来解决多进程之间的同步问题,总共有三个系统调用:semget,semop,semctl 12#include&lt;sys/sem.h&gt;int semget(key_t key,int num_sems,int sem_flags); key参数用来全局唯一表示一个信号量集,要通过信号量通信的进程需要使用相同的键值来创建/获取该信号量.num_sems指定要创建/获取的信号量集中信号量的数目,获取信号量可设置0\\sem_flags指定一组标志semget成功返回一个正整数值,他是信号量集的标示符,创建信号量集内核中关联的数据结构体semid_ds将被创建:1234567891011121314151617#include&lt;sys/sem.h&gt;struct ipc_perm&#123; key_t key;//键值 uid_t uid;//所有者的有效用户id gid_t gid;//所有者的有效组id uid_t cuid; gid_t cgid; mode_t mode;//访问权限&#125;;struct semid_ds&#123; struct ipc_perm sem_perm;//信号量的操作权限 unsigned long int sem_nsems;//信号量数目 time_t sem_otime;//最后一次调用semop的时间 time_t sem_ctime;//最后一次调用semctl的时间&#125;; semop系统调用改变信号量的值,主要改变内核中如下变量:unsigned short semval;//信号量的值unsigned short semzcnt; //等待信号量值变为0的进程数量unsigned short semncnt;//等待信号量pid_t sempid;//最后一次执行semop操作的进程ID12#include&lt;sys/sem.h&gt;int semop(int sem_id,struct sembuf* sem_ops,size_t num_sem_ops); 进程池实现一个进程池,池中所有的子进程都运行着相同的代码,并具有相同的属性,比如优先级,PGID,因为进程池在服务器启动之初就创建好了主进程选择子进程算法有随机选取和轮流选取算法主进程管理所有监听socket,如果有新的连接,通知子进程调用accept接受,无需传递连接socket我们用一个全局管道来统一事件源,为了让进程收到的信号不中断进程,用管道接受信号,然后注册到epoll内核事件表一起监听.每个子进程都有一个管道用来与父进程通信,主要是父进程通过管道通知子进程有新的连接到来. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284#ifndef PROC_POOL_H#define PROC_POOL_H#include\"./server_head.h\"//描述一个子进程的类class process&#123;public: process():m_pid(-1)&#123;&#125; ~process()&#123;&#125;private: pid_t m_pid;//自己的进程id int m_pipefd[2];//用来和父进程通信的管道&#125;;template&lt;typename T&gt;class processpool&#123;private: processpool(int listenfd,int process_number=8);//单例模式,构造函数私有public: static processpool&lt;T&gt;* create(int listenfd,int process_number)&#123; if(m_instance==nullptr)&#123; m_instance=new processpool&lt;T&gt;(listenfd,process_number); &#125; return m_instance; &#125; ~processpool()&#123; delete []this-&gt;m_sub_proc; void run();//启动进程池 void setup_sig_pipe(); void run_child(); void run_parent();pirvate: static const int MAX_PROCESS_NUMBER=16;//进程池最大子进程数量 static const int USER_PER_PROCESS=65536;//每个子进程最多能处理的客户数量 static const int MAX_EVENT_NUMBER=10000;//epoll最多能处理的事件数 int m_process_number;//进程池中的进程总数 int m_idx;//子进程在池中的序号 int m_epollfd;//每个进程都有一个内核事件表, int m_listenfd;//监听socket bool m_stop;//是否运行 process* m_sub_proc; static processpool&lt;T&gt;* m_instance;&#125;:template&lt;typename T&gt;processpool&lt;T&gt;::m_instance=nullptr;//静态成员函数初始化static int sig_pipefd[2];//用于处理进程收到信号的管道(和从父进程收到的信号分开),以实现统一事件源,信号管道//一些功能函数//设置fd为非阻塞 static int setnonblocking(int fd)&#123; int old_option=fcntl(fd,F_GETFL); fcntl(fd,F_SETFL,old_option|O_NONBLOCK); return old_option; &#125;static void addfd(int m_epollfd,int fd)&#123; epoll_event event; event.data.fd=fd; event.event=EPOLLIN|EPOLLET; epoll_ctl(m_epollfd,EPOLL_CTL_ADD,fd,&amp;event); setnonblocking(fd);&#125;static void removefd(int epollfd,int fd)&#123; epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,0); close(fd);&#125;static void sig_add(int sig,void(*handler)(int),bool restart=true)&#123; struct sigaction si; memset(&amp;si,0,sizeof(si)); si.sa_handler=handler; si.sa_flags|=restart?SA_RESTART:0; sigfillset(&amp;si.sa_mask);&#125; static void sig_handler(int sig)&#123; int save_errno=errno; send(sig_pipefd[0],static_cast&lt;char*&gt;&amp;sig,1,0);//?为什么只传1个字节 errno=save_errno;&#125;template&lt;typename T&gt;void processpool&lt;T&gt;::processpool(int listenfd,int process_number): m_listenfd(listenfd),m_process_number(process_number), m_idx(-1),(m_stop(false)&#123; assert(process_number&gt;0 &amp;&amp; process_number&lt;=MAX_PROCESS_NUMBER); m_sub_proc=new process[process_number]; for(int i=0;i&lt;process_number;i++)&#123; sockpair(PF_UNIX,SOCK_STREAM,0,m_sub_proc[i].m_pipefd); m_sub_proc[i].m_pid=fork(); if(m_sub_proc[i].m_pid==0)&#123; m_idx=i; close(m_sub_proc[i].m_pipefd[0]);//关闭写端 break; &#125;else&#123; close(m_sub_proc[i].m_pipefd[1]) &#125; &#125; &#125;template&lt;typename T&gt;processpool&lt;T&gt;::setup_sig_pipe()&#123; this-&gt;epollfd=epoll_create(5); assert(this-&gt;epollfd!=-1); assert(sockpair(PF_UNIX,SOCK_STREAM,0,sig_pipefd)); setnonblocking(sig_pipefd[1]); addfd(m_epollfd,sig_pipefd[0]); sig_add(SIGCHLD,sig_handler); sig_add(SIGTERM,sig_handler); sig_add(SIGINT,sig_handler); sig_add(SIGPIPE,SIG_IGN);template&lt;typename T&gt;void processpool&lt;T&gt;::run()&#123; if(this-&gt;m_idx!=0)&#123; run_child(); &#125;else&#123; run_parent(); &#125;&#125;//子进程调用epoll_wait,监听到的事件分类处理.template&lt;typename T&gt;void processpool::run_child()&#123; this-&gt;setup_sig_pipe();//第一步统一事件源 epoll_event events[MAX_EVENT_NUMBER]; T* user=new T[USER_PER_PROCESS]; int pipefd=this-&gt;m_sub_proc[m_idx].m_pipefd[0]; while(!this-&gt;m_stop)&#123; int number=epoll_wait(this-&gt;m_epollfd,events,MAX_EVENT_NUMBER,-1); if(number&lt;0&amp;&amp;(errno!=EINTER)&#123; printf(\"epoll failure\\n\"); break; &#125; for(int i=0;i&lt;number;i++)&#123; int sockfd=events[i].data.fd; if((sockfd==pipefd)&amp;&amp;(events[i].events &amp;EPOLLIN)&#123;//管道全双工,我们处理读事件 int client=0; recv(sockfd,(char*)&amp;client,sizeof(client),0); struct sockaddr_in client_address; socklen_t client_addrlength=sizeof(client_address); int connfd=accept(this-&gt;m_listenfd,(struct sockaddr*)&amp;client_address,&amp;client_addrlength); addfd(this-&gt;m_epollfd,connfd); user[connfd].init(m_epollfd,connfd,client_address);//具体处理方法的初始化 &#125;else if((sockfd==sig_pipefd[1])&amp;&amp;(events[i].event &amp; EPOLLIN))&#123; //处理信号,可能一次收到多个信号 int sig; char signals[1024]; int ret=recv(sockfd,signals,sizeof(signals),0); for(int i=0;i&lt;ret;i++)&#123; switch(signals[i])&#123;//信号占一个字节 case SIGCHLD://子进程终止信号 &#123; pid_t pid; int stat; while((pid=waitpid(-1,&amp;stat,WNOHANG) )&gt;0)&#123; continue; &#125; break; &#125; case SIGTERM: case SIGINT://终止信号 &#123; this-&gt;m_stop=true; break; &#125; default: &#123; break; &#125; &#125; &#125; &#125; else if(events[i].events &amp; EPOLLIN)&#123;//其他类型描述符,肯定是已连接描述符上请求到来 user[sockfd].process(); &#125;else&#123; continue; &#125; &#125; &#125; delete[] user; user=nullptr; close(pipefd); close(m_epollfd);&#125;template&lt;typname T&gt;void processpool&lt;T&gt;::run_parent()&#123; this-&gt;setup_sig_pipe(); addfd(this-&gt;m_epollfd,this-&gt;m_listenfd); epoll_event events[USER_PER_PROCESS]; int new_connfd=1; int sub_process_counter=0; while(!m_stop)&#123; int number=epoll_wait(this-&gt;m_epollfd,events,MAX_EVENT_NUMBER,-1); if((number&lt;0)&amp;&amp;(errno!=EINTER))&#123; printf(\"epoll failure\\n\"); break; &#125; for(int i=0;i&lt;number;i++)&#123; int sockfd=events[i].data.fd; if((sockfd==this-&gt;m_listenfd)&#123; //接下来通过随机选取算法选择一个子进程通知. int i=sub_process_counter; do&#123; if(m_sub_process[i].m_pid!=-1)&#123; break; &#125; i=(i+1)%m_process_number; &#125;while(i!=sub_process_counter); if(m_sub_process[i].m_pid==-1)&#123; m_stop=true; break; &#125; sub_process_counter=(i+1)%m_process_number; send(m_sub_process[i].m_pipefd[0],(char*)&amp;new_coon,sizeof(new_conn),0);//写入一个数值表示有新连接 printf(\"send requeset to child %d\\n\",i); &#125; else if((sockfd=sig_pipefd[1])&amp;&amp;(events[i].event&amp;EPOLLIN)&#123;//处理自己收到的信号 int sig; char signals[1024]; ret=recv(sig_pipefd[0],signals,sizeof(signals),0); if(ret&lt;=0)&#123; continue; &#125;else&#123; for(int i=0;i&lt;ret;i++)&#123; switch(signals[i])&#123; case SIGCHLD: &#123; pid_t pid; int stat; while((pid=waitpid(-1,&amp;stat,WNOHANG) )&gt;0)&#123; for(int i=0;i&lt;m_process_number;i++)&#123;//关闭通信管道的写端 if(this-&gt;m_sub_process[i].m_pid==pid)&#123; close(this-&gt;m_sub_process.m_pipefd[0]); m_sub_process[i].m_pid=-1; &#125; &#125; &#125; //如果没有子进程存在,则父进程也退出 m_stop=true; for(int i=0;i&lt;process_number;i++)&#123; if(m_sub_process[i].m_pid!=-1)&#123; m_stop=false; break; &#125; &#125; break; &#125; case SIGTERM: case SIGINT: &#123; printf(\"kill all child now\\n\"); for(int i=0;i&lt;m_process_number;i++)&#123; int pid=m_sub_process[i].m_pid; if(pid!=-1)&#123; kill(pid,SIGTERM); &#125; &#125; break; &#125; default: break; &#125; &#125; &#125; &#125; else&#123; continue; &#125; &#125; &#125; close(m_epollfd);&#125;#endif 线程同步为了使用方便,我们将posix线程标准下用来同步线程的三种锁进行封装,信号量,互斥量,条件变量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#ifndef LOCKER_H#define LOCKER_H#include\"./server_head.h\"class cond;class sem&#123;public: sem()&#123; if(sem_init(&amp;m_sem,0,0)!=0)&#123; throw std::exception(); &#125; &#125; ~sem()&#123; sem_destroy(&amp;m_sem); &#125; bool wait()&#123; return sem_wait(&amp;m_sem)==0; &#125; bool post()&#123; return sem_post(&amp;m_sem)==0; &#125;private: sem_t m_sem;&#125;;class locker&#123;public: friend class cond; locker()&#123; init(); &#125; ~locker()&#123; release(); &#125; void init()&#123; if(pthread_mutex_init(&amp;m_mutex,NULL)!=0) throw std::exception(); &#125; void release()&#123; pthread_mutex_destroy(&amp;m_mutex); &#125; bool lock()&#123; return pthread_mutex_lock(&amp;m_mutex)==0; &#125; bool unlock()&#123; return pthread_mutex_lock(&amp;m_mutex)==0; &#125;private: pthread_mutex_t m_mutex; pid_t m_pid;&#125;;class cond&#123;public: cond()&#123; m_lock.init(); if(!init())&#123; m_lock.release(); &#125; &#125; ~cond()&#123; m_lock.release(); this-&gt;release(); &#125; bool init()&#123; return pthread_cond_init(&amp;m_cond,NULL)==0; &#125; void release()&#123; pthread_cond_destroy(&amp;m_cond); &#125; bool signal()&#123; return pthread_cond_signal(&amp;m_cond)==0; &#125; bool broadcast()&#123; return pthread_cond_broadcast(&amp;m_cond)==0; &#125; bool wait()&#123; int ret=0; m_lock.lock(); ret=pthread_cond_wait(&amp;m_cond,&amp;m_lock.m_mutex); m_lock.unlock(); return ret==0; &#125;private: locker m_lock; pthread_cond_t m_cond;&#125;;#endif 线程池","tags":[{"name":"socket","slug":"socket","permalink":"http://yoursite.com/tags/socket/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"高性能服务器框架","date":"2017-08-27T06:59:39.000Z","path":"2017/08/27/高性能服务器框架/","text":"两种高效的事件处理方式 Reactor模式Reactor模式要求主线程只负责监听文件描述符的是否有事件发生,有的话就通知工作线程去处理,主线程本身不做任何实质性工作,接受新连接(accept),处理客户请求均在工作线程中完成使用同步I/O模型的话流程如下: 主线程往epoll内核事件表中注册socket上的读就绪事件(这步先不用注册写) 调用epoll_wait等待socket上有数据可读. 当socket上有数据可读时,epoll_wait通知主线程,主线程则将socket可读事件放入请求队列 线程池中某个睡眠状态的线程被唤醒,从socket读取数据,并处理客户请求,然后往epoll内核事件表中注册socket上的写就绪事件. 主线程调用epoll_wait等待socket可写 当socket可写时,epoll_wait通知主线程,主线程则将socket可写事件放入请求队列 线程池中某个睡眠状态的线程被唤醒,往socket写入服务器处理客户请求的结果 注意一点,读写用两个线程分开执行,但线程不区分只读线程和只写线程. Proactor模式Proactor模式相反,要求主线程处理所有的I/O操作,工作线程仅仅负责业务逻辑.使用异步I/O模型实现的Proactor模式工作流程: 主线程调用aio_read函数想内核注册socket上的读完成事件,并告诉内核用户读缓冲区的位置(这是为了能让读到的内容复制到用户缓冲区,如何实现),以及读操作完成时如何通知应用程序(一种方法用signal) 主线程继续处理其他逻辑 读入用户缓冲区后,内核将向应用程序发送一个信号,以通知应用程序数据可用. 收到信号,应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求,工作线程处理完客户请求后,调用aio_write(异步)函数向内核注册写完成事件,并告诉内核用户写缓冲区的位置,以及写操作完成时如何通知应用程序.(信号) 主线程继续处理其他逻辑 当用户缓冲区的数据被写入socket之后,内核将向应用程序,发送一个信号,以通知应用程序数据已经发送完毕. 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理,比如决定是否关闭socket. 同步I/O实现Proactor模式主线程执行数据读写操作,主线程向工作线程通知这一”完成事件”.那么从工作线程的角度来看,他们就直接获得了数据读写的结果,接下来要做的只是对读写的结果进行逻辑处理.与Reactor唯一的不同就是主线程读完socketfd中的内容,打包成请求对象入请求队列,然后唤醒工作线程来处理,然后向epoll中注册写就绪事件,接着主线程执行写操作. 两种高效的并发模式并发模式主要用来解决I/O密集型的情况,如果是计算密集型,用多线程反而由于任务切换过频繁导致效率降低.I/O操作的速度没有CPU的计算速度快,所以阻塞在I/O上会浪费CPU计算时间.如果一个线程阻塞在I/O,那么由操作系统调度该线程CPU占用率减小,给其他线程提高CPU占用率. 半同步/半异步模式在这种模式中,同步线程主要用来处理客户逻辑,相当于逻辑单元,异步线程用来处理IO事件,相当于IO处理单元.异步线程(主线程)监听到请求,封装成请求对象插入请求队列,请求队列将通知同步工作线程来处理,同步工作线程不会被中断. 半同步半反应堆模式特点: 异步线程只有一个，由主线程来充当，负责监听所有socket上的事件。 如果有新的连接请求，主线程就接受之，以得到新的连接socket 在epoll内核事件表中注册该socket上的读写事件 如果连接socket上有读写事件发生，即有新的客户请求到来或有数据要发送到客户端，主线程就将该连接socket插入请求队列。 所有工作线程都睡眠在请求队列上，当有任务到来时，它们将通过竞争获得任务的接管权。 缺点: 主线程和工作线程共享同一个请求队列,所以主线程在插入请求对象时,会加锁保护队列,使得工作线程无法读取请求对象.浪费CPU时间. 工作线程同一时间只能处理一个客户请求. 改进:主线程监听是否有新的连接,有的话就分配给工作线程,工作线程调用epoll_wait,将得到的新连接的事件添加到自己的epoll内核注册表中. 领导者/追随者模式领导者线程用来监听IO事件,如果检测到事件,首先推举一个新的追随者线程为领导者线程,然后去处理事件.领导者追随者模式包含如下几个组件:句柄集,线程集,事件处理器,和具体的事件处理器. 句柄集:用来表示IO资源,也就是文件描述符的集合 线程集:所有线程的管理者,其中的线程处于三种状态之一,leader,follower,processing. 事件处理器:一系列的回调函数,这些回调函数用来处理业务逻辑.用之前需要绑定一个文件描述符,这样有事件发生,就执行该事件处理器的回调函数. 具体的事件处理器:事件处理的派生类,重载父类的回调函数,用来处理特定的任务. 接下来说明对于http的报文如何解析. 有限状态机有限状态机就是每次循环执行和状态相对应的逻辑,然后转移到下一种状态,比如在http报文分析中,我们将主状态分为读请求行和读头部字段,从状态分为每行的读取状态:读完一行,行不完整,行有错误.然后每次循环读一行,对主状态switch,先解析请求行,然后转移主状态,再次循环执行解析头部字段. 提高性能的其他建议 池化思想:不要动态分配线程进程,用事先分配好的线程池或进程池,减小系统调用开销 数据复制:避免不必要的数据复制,特别在用户空间和内核空间之间. 上下文切换和锁:不要使用过多线程,减小上下文切换的开销.不要频繁使用锁,会降低线程的并发性.","tags":[{"name":"c","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/服务器/"}]},{"title":"自制radix_tree","date":"2017-08-21T07:21:12.000Z","path":"2017/08/21/自制radix-tree/","text":"介绍前缀树radix tree,中文基数树,是用来解决hash冲突和hash表的设计,前缀树是一种有序树,用于保存关联数组,键一般都为字符串.每个节点的所有子孙都有相同的前缀.最后所有的叶子节点保存了要存储的元素.前缀树经常用于搜索提示,比如输入一个网址,可以自动搜索出可能的选择.前缀树的问题在于可能过于稀疏,空间浪费严重.比如几个字符串有相同某段前缀,但是如果按每个字符来分的话,会出现很多没有用的节点. 前缀压缩树为了解决问题,出现了压缩前缀树,对于基数树的每个节点,如果该节点是唯一的儿子的话,就和父节点合并.下面就来自己实现一个基数树容器. 组件首先,是一颗树,就必须有节点类的定义,radix_tree_node,其次,既然是容器,我们需要一个迭代器的类,最后是radix_tree本身. 节点第一,节点要存什么,节点要存的信息有键和要存的元素,我们可以用一个pair来实现,其次,节点要有子节点,由于子节点数量不确定,我们可以用map来存,如果用线性表来存访问速度就会是O(n).为了方便还存了父节点和键.声明代码如下:12345678910111213141516171819202122template &lt;typename K, typename T&gt;class radix_tree_node &#123; friend class radix_tree&lt;K, T&gt;; friend class radix_tree_it&lt;K, T&gt;; typedef std::pair&lt;const K, T&gt; value_type; typedef typename std::map&lt;K, radix_tree_node&lt;K, T&gt;* &gt;::iterator it_child;private://构造和析构 radix_tree_node() : m_children(), m_parent(NULL), m_value(NULL), m_depth(0), m_is_leaf(false), m_key() &#123; &#125; radix_tree_node(const value_type &amp;val); ~radix_tree_node();//类成员 std::map&lt;K, radix_tree_node&lt;K, T&gt;*&gt; m_children; radix_tree_node&lt;K, T&gt; *m_parent; value_type *m_value; int m_depth; bool m_is_leaf; K m_key;&#125;; 重载析构在初始化对象的时候，根据参数的不同，使用不同的构造函数，这里我们写了重载构造函数和删除对象时的析构函数： 12345678910111213141516171819202122template &lt;typename K, typename T&gt;radix_tree_node&lt;K, T&gt;::radix_tree_node(const value_type &amp;val) : m_children(), m_parent(NULL), m_value(NULL), m_depth(0), m_is_leaf(false), m_key()&#123; m_value = new value_type(val);&#125;template &lt;typename K, typename T&gt;radix_tree_node&lt;K, T&gt;::~radix_tree_node()&#123; it_child it; for (it = m_children.begin(); it != m_children.end(); ++it) &#123; delete it-&gt;second; &#125; delete m_value;&#125; 要注意释放申请的内存 迭代器我们要定义树的迭代器,首先迭代器能访问树节点上保存的信息(键值),不能访问其他信息,自己定义的迭代器最好继承标准库迭代器std::iterator: 1234567891011121314151617181920212223242526template &lt;typename K, typename T&gt;//要继承的iterator实例化参数要加std::forward_iterator_tag,因为树是向前迭代器class radix_tree_it : public std::iterator&lt;std::forward_iterator_tag, std::pair&lt;K, T&gt; &gt; &#123; friend class radix_tree&lt;K, T&gt;;public: radix_tree_it() : m_pointee(0) &#123; &#125; radix_tree_it(const radix_tree_it&amp; r) : m_pointee(r.m_pointee) &#123; &#125; radix_tree_it&amp; operator=(const radix_tree_it&amp; r) &#123; m_pointee = r.m_pointee; return *this; &#125; ~radix_tree_it() &#123; &#125; std::pair&lt;const K, T&gt;&amp; operator* () const; std::pair&lt;const K, T&gt;* operator-&gt; () const; const radix_tree_it&lt;K, T&gt;&amp; operator++ (); radix_tree_it&lt;K, T&gt; operator++ (int); // const radix_tree_it&lt;K, T&gt;&amp; operator-- (); bool operator!= (const radix_tree_it&lt;K, T&gt; &amp;lhs) const; bool operator== (const radix_tree_it&lt;K, T&gt; &amp;lhs) const;private: radix_tree_node&lt;K, T&gt; *m_pointee; radix_tree_it(radix_tree_node&lt;K, T&gt; *p) : m_pointee(p) &#123; &#125; radix_tree_node&lt;K, T&gt;* increment(radix_tree_node&lt;K, T&gt;* node) const; radix_tree_node&lt;K, T&gt;* descend(radix_tree_node&lt;K, T&gt;* node) const;&#125;; 我们重载了一些操作符,接下来看如何实现 操作符123456789101112131415161718192021222324252627282930313233343536373839template &lt;typename K, typename T&gt;std::pair&lt;const K, T&gt;&amp; radix_tree_it&lt;K, T&gt;::operator* () const&#123; return *m_pointee-&gt;m_value;&#125;template &lt;typename K, typename T&gt;std::pair&lt;const K, T&gt;* radix_tree_it&lt;K, T&gt;::operator-&gt; () const&#123; return m_pointee-&gt;m_value;&#125;template &lt;typename K, typename T&gt;bool radix_tree_it&lt;K, T&gt;::operator!= (const radix_tree_it&lt;K, T&gt; &amp;lhs) const&#123; return m_pointee != lhs.m_pointee;&#125;template &lt;typename K, typename T&gt;bool radix_tree_it&lt;K, T&gt;::operator== (const radix_tree_it&lt;K, T&gt; &amp;lhs) const&#123; return m_pointee == lhs.m_pointee;&#125;template &lt;typename K, typename T&gt;const radix_tree_it&lt;K, T&gt;&amp; radix_tree_it&lt;K, T&gt;::operator++ ()&#123; if (m_pointee != NULL) m_pointee = increment(m_pointee); return *this;&#125;template &lt;typename K, typename T&gt;radix_tree_it&lt;K, T&gt; radix_tree_it&lt;K, T&gt;::operator++ (int)&#123; radix_tree_it&lt;K, T&gt; copy(*this); ++(*this); return copy;&#125; 实现increment和descend关键在于如何遍历树的叶子节点,从一个叶子节点要寻找的下一个节点要么是自己的下一个兄弟节点,需要通过父节点来访问到,要么自己已经是最后一个兄弟节点,这时候需要找父节点的下一个兄弟节点,再往下找到叶子节点 123456789101112131415161718192021222324252627282930template &lt;typename K, typename T&gt;radix_tree_node&lt;K, T&gt;* radix_tree_it&lt;K, T&gt;::increment(radix_tree_node&lt;K, T&gt;* node) const&#123; radix_tree_node&lt;K, T&gt;* parent = node-&gt;m_parent; if (parent == NULL) return NULL; typename radix_tree_node&lt;K, T&gt;::it_child it = parent-&gt;m_children.find(node-&gt;m_key); assert(it != parent-&gt;m_children.end()); ++it; if (it == parent-&gt;m_children.end()) return increment(parent); else return descend(it-&gt;second);&#125;template &lt;typename K, typename T&gt;radix_tree_node&lt;K, T&gt;* radix_tree_it&lt;K, T&gt;::descend(radix_tree_node&lt;K, T&gt;* node) const&#123; if (node-&gt;m_is_leaf) return node; typename radix_tree_node&lt;K, T&gt;::it_child it = node-&gt;m_children.begin(); assert(it != node-&gt;m_children.end()); return descend(it-&gt;second);&#125; 接下来要实现radix_tree,也是核心部分. radix_tree","tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"创建博客网站项目启动","date":"2017-06-25T10:43:58.000Z","path":"2017/06/25/创建博客网站项目启动/","text":"题外 一个多月没写博客了,最近也没怎么看书,搞了几个算法比赛也一无所获,感觉自己越来越懒了,从现在开始给自己一个规定,每周六必须定期写一篇,如果没东西总结归纳说明这周就没干什么事情. web项目 这周开始准备跟着狗书还有网上资源,做一个社交博客网站,从这个项目里期望能对web开发整个框架有一个具体的认识.所用到的技术和要点如下: Python语法基础,重点在于装饰器 Flask框架学习 数据库基础,掌握基本sql语言 前端基础,html语法和css样式 服务器和http协议 目前刚刚看完Python基础语法和数据库的基本操作,但是Python写程序还很生涩,要多加练习,接下来计划一周完成flask基础学习和前端入门,加上博客的各个模块的简要实现.加油!","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"},{"name":"web 开发","slug":"web-开发","permalink":"http://yoursite.com/tags/web-开发/"},{"name":"Flask框架","slug":"Flask框架","permalink":"http://yoursite.com/tags/Flask框架/"}]},{"title":"select,poll和epoll","date":"2017-05-17T02:18:12.000Z","path":"2017/05/17/select-poll和epoll-1/","text":"selectselect函数允许进程指示内核等待多个事件中的任何一个发生,只有在一个或多个事件(描述符状态变化)发生或者阻塞时间超时会返回.select的接口如下: #include&lt;sys/select.h&gt; #include&lt;sys/time.h&gt; int select(int maxfdp1,fd_set* readset,fd_set* writeset,fd_set* exceptset,const struct timeval* timeout); 其中第一个参数表示所有关心的描述符总数,即后面三个集合中描述符的数量和,后面三个参数分别表示测试读写和异常条件的描述符.最后一个参数表示最大阻塞时间,即超过时间没有描述符就绪则返回. struct timeval{ long tv_sec;// 秒数 long tv_usec;// 微妙数 }; fd_set这个结构的初始化和赋值使用已定义的宏: void FD_ZERO(fd_set \\*fdset); //初始化清零 void FD_SET(int fd,FD_SET \\*fdset); //设置某一位描述符 void FD_CLR(int fd,FD_SET \\*fdset); //清除某一位描述符 int FD_ISSET(int fd,FD_SET \\*fdset); //测试是否有指定位描述符 对于select返回某个套接字就绪的条件,总结如下: 条件 可读吗? 可写吗? 异常吗? 有数据可读 Y 关闭连接的读一半 Y 给监听套接口准备好新连接 Y 有可用于写的空间 Y 关闭连接的写一半 Y 待处理错误 Y Y TCP带外数据 Y 说明:关闭套接字的读一半后,执行读操作会立即返回EOF,所以也算作可读状态,关闭写一半,执行写操作会立即返回SIGPIPE信号,算作可写状态. pollpoll功能和select相似,在处理流设备时,能提供额外信息.poll函数接口原型: #include&lt;poll.h&gt; int poll(struct pollfd *fdarray,unsigned long nfds,int timeout); 结构体 pollfd的定义: struct pollfd{ int fd; //要测试的描述符 short events; //感兴趣的事件(读写异常) short revents; //发生的事件 }; POSIX定义了events标志的一些常值 常值 作为events输入吗 作为revents输出吗 说明 POLLIN Y Y 普通或优先级带数据可读 POLLRDNORM Y Y 普通数据可读 POLLOUT Y Y 普通数据可写 POLLERR Y 发生错误 参数nfds表示套接字的数量 epollselect的缺点有两个,第一,针对每个描述符的循环语句.第二,每次调用都要向操作系统传递套接字信息,造成无法优化的负担.为了解决第二个问题,epoll仅向操作系统传递一次监视对象,监视范围或者内容发生变化式只通知发生变化的事项(注意,Linux才支持epoll)epoll实现需要3个函数接口: epoll_create:创建保存epoll文件描述符的空间 epoll_ctl:向空间注册并注销文件描述符 epoll_wait:与select函数类似,等待文件描述符的变化.12345678910111213141516#include&lt;sys/epoll.h&gt;int epoll_create(int size);//成功返回文件描述符，创建的fd保存空间在内核中，size为建议的空间大小，用完需要调用close关闭.int epoll_ctl(int epfd,int op,int fd,struct epoll_event \\*event);//用来添加需要监视的fd。int epoll_wait(int epfd,struct epoll_event \\*events,int maxevents,int timeout);//成功返回就绪fd数量struct epoll_event&#123; __uint32_t events; epoll_data_t data;&#125;typedef union epoll_data&#123; void* ptr; int fd; __uint32_t u32; __uint64_t u64;&#125;epoll_data_t; epoll_ctl中op选项: EPOLL_CTL_ADD EPOLL_CTL_DEL EPOLL_CTL_MOD:更改出册的文件描述符的关注事件发生情况 epoll_events中的events常用值: EPOLLIN:需要读取数据的情况 EPOLLOUT:输出缓冲为空,可以立即发送数据的情况 EPOLLRDHUP:断开连接或者半关闭的情况 EPOLLERR:错误情况 EPOLLLET:以边缘触发的方式 EPOLLONESHOT:发生一次事件后,相应描述符不在收到事件通知(所以需要EPOLL_CTL_MOD选项.再次设置) epoll_wait中events保存就绪的描述符,所以需要给它动态分配缓存区,maxevents用来指示第二个参数最大数量. #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;sys/socket.h&gt; #include&lt;sys/epoll.h&gt; #include&lt;arpa/inet.h&gt; #include&lt;unistd.h&gt; #include&lt;string.h&gt; const int BUF_SIZE=100; const int EPOLL_SIZE=50; void error_handling(const char* message); int main(int argc,char** argv) { int serv_sock,clnt_sock; struct sockaddr_in serv_adr,clnt_adr; char buf[BUF_SIZE]; struct epoll_event* ep_events; struct epoll_event event; int epfd,event_cnt; if(argc!=2){ printf(&quot;Usage: %s&lt;port&gt;\\n&quot;,argv[0]); exit(1); } serv_sock=socket(PF_INET,SOCK_STREAM,0); memset(&amp;serv_adr,0,sizeof(serv_adr)); serv_adr.sin_family=AF_INET; serv_adr.sin_addr.s_addr=htonl(INADDR_ANY); serv_adr.sin_port=htons(atoi(argv[1])); if(bind(serv_sock,(struct sockaddr*)&amp;serv_adr,sizeof(serv_adr))==-1) error_handling(&quot;bind() error&quot;); if(listen(serv_sock,5)==-1) error_handling(&quot;listen() error&quot;); //创建epoll epfd=epoll_create(EPOLL_SIZE); ep_events=(struct epoll_event*)malloc(sizeof(struct epoll_event)*EPOLL_SIZE); event.events=EPOLLIN; event.data.fd=serv_sock; epoll_ctl(epfd,EPOLL_CTL_ADD,serv_sock,&amp;event); //监听 while(1) { event_cnt=epoll_wait(epfd,ep_events,EPOLL_SIZE,-1); if(event_cnt==-1){ puts(&quot;epoll_wait() error&quot;); break; } for(int i=0;i&lt;event_cnt;i++){ if(ep_events[i].data.fd==serv_sock) { socklen_t adr_sz=sizeof(clnt_adr); clnt_sock=accept(serv_sock,(struct sockaddr*)&amp;clnt_adr,&amp;adr_sz); event.events=EPOLLIN; event.data.fd=clnt_sock; epoll_ctl(epfd,EPOLL_CTL_ADD,clnt_sock,&amp;event); printf(&quot;connected client: %d \\n&quot;,clnt_sock); }else{ int str_len=read(ep_events[i].data.fd,buf,BUF_SIZE); if(str_len==0) { epoll_ctl(epfd,EPOLL_CTL_DEL,ep_events[i].data.fd,NULL); close(ep_events[i].data.fd); printf(&quot;Disconnected client: %d \\n&quot;,ep_events[i].data.fd); }else{ write(ep_events[i].data.fd,buf,str_len); } } } } close(serv_sock); close(epfd); return 0; } void error_handling(const char* message){ fputs(message,stderr); fputc(&apos;\\n&apos;,stderr); exit(1); } 条件触发和边缘出发条件触发:只要满足条件,就触发一个事件(例如缓冲区的数据没有读完,内核会一直通知)边缘触发:每当状态变化时,触发一个事件. “举个读socket的例子，假定经过长时间的沉默后，现在来了100个字节，这时无论边缘触发和条件触发都会产生一个read ready notification通知应用程序可读。应用程序读了50个字节，然后重新调用api等待io事件。这时水平触发的api会因为还有50个字节可读从 而立即返回用户一个read ready notification。而边缘触发的api会因为可读这个状态没有发生变化而陷入长期等待。 因此在使用边缘触发的api时，要注意每次都要读到socket返回EWOULDBLOCK为止，否则这个socket就算废了。而使用条件触发的api 时，如果应用程序不需要写就不要关注socket可写的事件，否则就会无限次的立即返回一个write ready notification。大家常用的select就是属于水平触发这一类，长期关注socket写事件会出现CPU 100%的毛病。 引用自网友博客的总结:epoll的优点：1.支持一个进程打开大数目的socket描述符(FD) select 最不能忍受的是一个进程所打开的FD是有一定限制的，由FD_SETSIZE设置，默认值是2048。对于那些需要支持的上万连接数目的IM服务器来说显 然太少了。这时候你一是可以选择修改这个宏然后重新编译内核，不过资料也同时指出这样会带来网络效率的下降，二是可以选择多进程的解决方案(传统的 Apache方案)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完 美的方案。不过 epoll则没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。 2.IO效率不随FD数目增加而线性下降 传统的select/poll另一个致命弱点就是当你拥有一个很大的socket集合，不过由于网络延时，任一时间只有部分的socket是”活跃”的， 但是select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。但是epoll不存在这个问题，它只会对”活跃”的socket进行 操作—这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有”活跃”的socket才会主动的去调用 callback函数，其他idle状态socket则不会，在这点上，epoll实现了一个”伪”AIO，因为这时候推动力在os内核。在一些 benchmark中，如果所有的socket基本上都是活跃的—比如一个高速LAN环境，epoll并不比select/poll有什么效率，相 反，如果过多使用epoll_ctl,效率相比还有稍微的下降。但是一旦使用idle connections模拟WAN环境,epoll的效率就远在select/poll之上了。 3.使用mmap加速内核与用户空间的消息传递。 这点实际上涉及到epoll的具体实现了。无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就 很重要，在这点上，epoll是通过内核于用户空间mmap同一块内存实现的。而如果你想我一样从2.5内核就关注epoll的话，一定不会忘记手工 mmap这一步的。 4.内核微调 这一点其实不算epoll的优点了，而是整个linux平台的优点。也许你可以怀疑linux平台，但是你无法回避linux平台赋予你微调内核的能力。 比如，内核TCP/IP协议栈使用内存池管理sk_buff结构，那么可以在运行时期动态调整这个内存pool(skb_head_pool)的大小 — 通过echo XXXX&gt;/proc/sys/net/core/hot_list_length完成。再比如listen函数的第2个参数(TCP完成3次握手 的数据包队列长度)，也可以根据你平台内存大小动态调整。更甚至在一个数据包面数目巨大但同时每个数据包本身大小却很小的特殊系统上尝试最新的NAPI网 卡驱动架构。","tags":[{"name":"unp","slug":"unp","permalink":"http://yoursite.com/tags/unp/"},{"name":"unix","slug":"unix","permalink":"http://yoursite.com/tags/unix/"}]},{"title":"5种IO模型总结","date":"2017-05-16T10:20:02.000Z","path":"2017/05/16/5种IO模型总结-1/","text":"在unix环境下,有5种IO模型,前4种属于同步IO: 阻塞式IO 非阻塞式IO IO复用(select和poll,还有更好的epoll) 信号驱动式IO(SIGIO) 异步IO(aio_系列函数) 阻塞式IO最流行的IO模型,默认情况下,所有套接字都是阻塞的,例如read,write,recvfrom.不再赘述(要注意不等于同步) 非阻塞式IO进程把一个套接字设置成非阻塞是在通知内核:当所请求的IO操作非得把本进程投入睡眠才能完成时,不要把本进程投入睡眠,而是返回一个错误.例如调用recvfrom时,如果内核空间无数据报准备好,则立即返回EWOULDBLOCK错误.如果有的话就会阻塞一直到IO完成.(按理论来说这种也属于同步IO)当一个应用进程对一个非阻塞描述符循环调用recvfrom时,称之为轮询,缺点式耗费cpu. IO复用模型调用select,系统阻塞在这个系统调用上,而不是真正的IO系统调用上,例如进程调用select,等待任一套接字变可读,一旦返回说明某个套接字的状态发生了变化,之后继续处理. 信号驱动式即让内核在描述符就绪时发送信号SIGIO通知进程,可以通过开启套接字的信号驱动式IO功能,通过sigaction系统调用安装一个信号处理函数.这种优势在于等待数据报到达期间进程不被阻塞. 异步IO模型告知内核某个操作,并让内核在整个操作完成后再通知进程. 总结:前四种IO的第一步各不相同,但第二部都一样,都会阻塞等待IO完成.但第五种不会阻塞.","tags":[{"name":"unp","slug":"unp","permalink":"http://yoursite.com/tags/unp/"},{"name":"unix","slug":"unix","permalink":"http://yoursite.com/tags/unix/"},{"name":"socket","slug":"socket","permalink":"http://yoursite.com/tags/socket/"}]},{"title":"字符串匹配KMP算法","date":"2017-03-28T06:09:15.000Z","path":"2017/03/28/字符串匹配KMP算法/","text":"题目:给定一个待匹配字符串和一个模板字符串,要求找到该串中模板字符串首次出现的位置,如果没有则返回-1. 第一种方法:朴素字符串匹配算法,也就是暴力枚举法,对需要匹配的字符串的每个字符进行一次匹配(在这里一次匹配操作是指两个等长字符串匹配),伪代码如下: 123456NAIVE_STRING_MATCHER(T,P)n=T.lengthm=P.lengthfor s=0 to n-m ifP[1..m]==T[s+1..s+m]return s; 其中第五行的操作记为比较两个等长字符串是否相等.类似于strcmp()函数,这些都很好理解,strcmp()复杂度最高为O(L)(L为待匹配字符串长度).所以整个算法时间复杂度为O(M*N) 第二种方法:KMP算法,为了由于朴素算法每一次的不匹配只移动一个偏移量,这会导致之前的已匹配区域重复匹配,为了能确定不匹配时该移动多少偏移量从而能利用之前的信息,所以我们需要一个next数组,也就是能确定当字符不匹配时,模板字符串向右移多少偏移量(数组的值真正记录的是在该位置前缀后缀最大公共长度,也就是该位置长度减去需要的偏移量).举个例子来说: 假设字符串”ababcba”,模板字符串是”abc”, 首先 a b c b a b a 由于c和a不等(此时位置在b,我们确定的是下一个字符匹配) 于是我们只移动模板2个偏移量,继续匹配 a b a a b c b a b a对应于next[2]=0(2-2); a b c 所以关键就是计算next数组. next数组计算伪代码如下: 123456789101112 COMPUTE_PREFIX_FUNCITION(P) m=P.length let next[1..m] be a new array next[1]=0 k=0 for q=2 to m while k&gt;0 and P[k+1]!=P[q] k=next[k] if P[k+1]==P[q] k=k+1next[q]=k; return next; 算法关键就在于第7-8行,while循环的总时间为O(m),从观察k的值开始,第一,在第5行,k初始值为0,并且增加k的唯一方法是通过第10行的递增操作,该操作在第6-11行的for循环中每次最多执行一次,因为k最多增加m-1次,第二,刚进行for循环时,k小于q,并且每次循环q都会增加,所以k永远小于q因此next[q]永远小于q,所以while循环会使q递减.所以while循环最多迭代m-1次. 下面是之前那道题的两种解法:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/*完成函数int strStr(const string&amp; str1,const string str2)功能,找到str1中子串str2的首字符出现的位置,如果没有则返回0 * 暴力解法O(m*n),也可以利用高效的字符串匹配算法例如KMP算法.*/#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;class Solution&#123;public: int strStr(const string&amp; haystack,const string&amp; needle)&#123; if(needle.empty())return 0; auto pos=haystack.begin(); const int N=haystack.size()-needle.size()+1; for(int i=0;i&lt;N;i++)&#123; int j=i; int k=0; while(j&lt;haystack.size()&amp;&amp;k&lt;needle.size()&amp;&amp;haystack[j]==needle[k])&#123; k++; j++; &#125; if(k==needle.size()) return i; &#125; return -1; &#125;&#125;;/*KMP算法.时间复杂度O(M+N),空间复杂度O(M)*/class Solution&#123;public: //KMP主程序,用预处理过的next数组来控制每次不匹配的偏移量,如果莫一个字符不匹配,那么直接找到needle中某一个字符和haystack的下一个字符匹配,这样永远不会回头,总匹配次数最多为字符串长度. int strStr(const string&amp; haystack,const string&amp; needle)&#123; if(needle.size()==0)return 0; vector&lt;int&gt; next=compute_next(needle); int q=-1; for(int i=0;i&lt;haystack.size();i++)&#123; while(q&gt;-1&amp;&amp;haystack[i]!=needle[q+1]) q=next[q]; if(haystack[i]==needle[q+1]) q++; if(q==(needle.size()-1)) return i-q; &#125;return -1; &#125;//用来计算next数组的算法.具体原理参照算法导论32章. static vector&lt;int&gt; compute_next(const string&amp; s)&#123; vector&lt;int&gt; next(s.size(),-1); if(s.size()==0)return next; int q=-1; for(int i=1;i&lt;s.size();i++)&#123; while(q&gt;-1&amp;&amp;s[i]!=s[q+1])//不匹配时要返回的位置 q=next[q]; if(s[i]==s[q+1])//如果下个字符匹配,那么直接继承之前的已匹配区域. q++; next[i]=q; &#125; return next; &#125;&#125;;int main()&#123; string s1=\"ababcd\"; string needle=\"abc\"; Solution s; cout&lt;&lt;s.strStr(s1,needle)&lt;&lt;endl;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"检查带环链表入口问题","date":"2017-03-24T12:21:11.000Z","path":"2017/03/24/检查带环链表入口问题/","text":"这两天一直在做链表的题目,遇到了一道有环链表的问题,感觉很有趣:题目:给一个链表,如果有回路返回回路开始的节点,没有回路则返回NULL 思路:两个指针一快一慢,fas与slow相遇时,fast已经在圈内循环了n圈,设slow走了n步,则fast走了2s步(fast步数还等于s加上在环上多转的n圈),设环长为r,于是: 2s=s+nr s=nr 设整个链表长L,环入口点与相遇点距离为a,起点到环入口点的距离为x,则: x+a=nr=(n-1)r+r=(n-1)r+L-x x=(n-1)r+(L-x-a) L-x-a为相遇点到环入口点的距离,由此可知,从链表头到环入口点等于n-1圈内环+相遇点到入口点,于是我们可以从head开始另设一个指针slow2,两个慢指针 slow2,两个慢指针每次前进一步,它俩一定会在环入口点相遇*/ 2.2.12.cpp1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;struct ListNode&#123; int val; ListNode* next; ListNode(int x):val(x),next(NULL)&#123;&#125;&#125;;class Solution&#123; ListNode* detectCycle(ListNode* head)&#123; ListNode* slow=head,*fast=head; while(fast&amp;&amp;fast-&gt;next)&#123; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; if(slow==fast)&#123; ListNode* slow2=head; while(slow2!=slow)&#123; slow2=-&gt;slow2-&gt;next; slow=slow-&gt;next; &#125; return slow2; &#125; &#125; return NULL; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"互斥量和避免死锁","date":"2017-03-15T05:17:04.000Z","path":"2017/03/15/互斥量和避免死锁/","text":"互斥量互斥变量是用pthread_mutex_t数据类型表示的,在使用互斥变量之前,必须首先对它进行初始化,可以把它设置为常量PTHREAD_MUTEX_INITIALIZER(只适用于静态分配的互斥量),也可以调用pthread_mutex_init进行初始化,如果动态分配互斥量,在释放内存前需要调用pthread_mutex_destory.1234567#include&lt;pthread.h&gt;int pthread_mutex_init(pthread_mutex_t* restrict mutex, const pthread_mutexattr_t* restrict attr);int pthread_mutex_destory(pthread_mutex_t* mutex);int pthread_mutex_lock(pthread_mutex_t* mutex);int pthread_mutex_trylock(pthread_mutex_t* mutex); //不阻塞,只尝试加锁,若失败返回EBUSY.int pthread_mutex_unlock(pthread_mutex_t* mutex); 死锁如果线程试图对同一个互斥量加锁两次,那么它自身就会陷入死锁状态,但是使用互斥量时,还有其他不太明显的方式也能产生死锁,例如,程序中使用一个以上的互斥量时,如果允许一个线程一直占用第一个互斥量,并且在试图锁住第二个互斥量时处于阻塞状态,但是拥有第二个互斥量的线程也在师徒锁住第一个互斥量.因为两个线程都在相互请求另一个线程拥有的资源,所以这两个线程都无法向前运行,于是就产生死锁.解决办法就是控制互斥量加锁顺序,比如同时要对互斥量A和B加锁,如果所有线程总是在对B加锁前锁住A,那么使用这两个就不会产生死锁.可以参考下面的例子:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;stdlib.h&gt;#include&lt;pthread.h&gt;const int NHASH=29;#define HASH(id) (((unsigned long)id)%NHASH)pthread_mutex_t hashlock=PTHREAD_MUTEX_INITIALIZER;struct foo&#123; int f_count; pthread_mutex_t f_lock; int f_id; struct foo* f_next;//protected by hashlock&#125;;struct foo* fh[NHASH];struct foo* foo_alloc(int id)&#123; struct foo* fp; int idx; if((fp=(struct foo*)malloc(sizeof(struct foo)))!=NULL)&#123; fp-&gt;f_count=1; fp-&gt;f_id=id; if(pthread_mutex_init(&amp;fp-&gt;f_lock,NULL)!=0)&#123; free(fp); return NULL; &#125; idx=HASH(id); pthread_mutex_lock(&amp;hashlock); fp-&gt;f_next=fh[idx]; fh[idx]=fp; pthread_mutex_lock(&amp;fp-&gt;f_lock); pthread_mutex_unlock(&amp;hashlock); &#125; return fp;&#125;void foo_hold(struct foo* fp)&#123; pthread_mutex_lock(&amp;fp-&gt;f_lock); fp-&gt;f_count++; pthread_mutex_unlock(&amp;fp-&gt;f_lock);&#125;struct foo* foo_find(int id)&#123; struct foo* fp; pthread_mutex_lock(&amp;hashlock); for(fp=fh[HASH(id)];fp!=NULL;fp=fp-&gt;f_next)&#123; if(fp-&gt;f_id==id)&#123; fp-&gt;f_count++; break; &#125; &#125; pthread_mutex_unlock(&amp;hashlock); return fp;&#125;//第一个版本的释放函数,严格按照每种互斥量的功能来锁住临界区,由于需要考虑互斥量使用顺序,会导致代码变得复杂.(foo_rele函数中先上锁在观察是否需要修改fh散列表,如果需要修改则必须先解锁在按顺序上锁)void foo_rele(struct foo* fp)&#123; struct foo* tfp; int idx; pthread_mutex_lock(&amp;fp-&gt;f_lock); if(fp-&gt;f_count==1)&#123; pthread_mutex_unlock(&amp;fp-&gt;f_lock); pthread_mutex_lock(&amp;hashlock); pthread_mutex_lock(&amp;fp-&gt;f_lock); if(fp-&gt;f_count!=1)&#123; fp-&gt;f_count--; pthread_mutex_unlock(&amp;fp-&gt;f_lock); pthread_mutex_unlock(&amp;hashlock); return; &#125;else&#123; idx=HASH(fp-&gt;f_id); tfp=fh[idx]; if(tfp==fp)&#123; fh[idx]=fp-&gt;f_next; &#125;else&#123; while(tfp-&gt;f_next!=fp) tfp=tfp-&gt;f_next; tfp-&gt;f_next=fp-&gt;f_next; &#125; &#125; pthread_mutex_unlock(&amp;fp-&gt;f_lock); pthread_mutex_unlock(&amp;hashlock); pthread_mutex_destory(&amp;fp-&gt;f_lock); free(fp); &#125;else&#123; fp-&gt;f_count--; pthread_mutex_unlock(&amp;fp-&gt;f_lock); &#125;&#125;//第二个版本的释放函数.直接用hashlock来锁住对fp的操作,避免了两个互斥量使用的顺序问题.简化了代码.但是线程阻塞的概率会更大,因为hashlock使用的范围更大.需要权衡两者的使用.void foo_rele2(struct foo* fp)&#123; struct foo* tfp; int idx; pthread_mutex_lock(&amp;hashlock); if(--fp-&gt;f_count==0)&#123; idx=HASH(fp-&gt;f_id); tfp=fh[idx]; if(tfp==fp)&#123; fh[idx]=fp-&gt;f_next; &#125;else&#123; while(tfp-&gt;f_next!=fp) tfp=tfp-&gt;f_next; tfp-&gt;f_next=fp-&gt;f_next; &#125; pthread_mutex_unlock(&amp;hashlock); pthread_mutex_destory(&amp;fp-&gt;f_lock); free(fp); &#125;else pthread_mutex_unlock(&amp;hashlock);&#125;","tags":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/tags/apue/"},{"name":"c","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"fork()和vfork()的总结","date":"2017-03-04T07:04:27.000Z","path":"2017/03/04/fork-和vfork-的总结/","text":"fork()函数可以创建一个新的进程,被称为子进程,子进程获得父进程数据空间,堆和栈的副本.父子进程不共享这些存储空间部分,共享正文段. 看下面一个实例:8.3.c/*打印父子进程的输出*/123456789101112131415161718192021#include \"apue.h\" int globvar= 6;char buf[] = \"a write to stdout\\n\"int main()&#123; int var; pid_t pid; var=88; if(write(STDOUT_FILENO,buf,sizeof(buf)-1)!=sizeof(buf)-1) err_sys(\"write error\"); printf(\"before fork\\n\"); if((pid=fork())&lt;0) err_sys(\"fork error\"); else if(pid==0)&#123; globvar++; var++; &#125;else sleep(2); printf(\"pid=%ld,glob=%d,var=%d\\n\",(long)getpid(),globvar,var); exit(0);&#125; 运行后结果:123456$ gcc 8.3.c -o8.3 -lapue$ ./8.3a write to stdoutbefore forkpid=5423,glob=7,var=89pid=5422,glob=6,var=88一切正常运行,但是如果我们重定向标准输出流之后:1234567$ ./8.3 &gt; temp.out$ cat temp.outa write to stdoutbefore forkpid=5481,glob=7,var=89before forkpid=5480,glob=6,var=88 可以看到printf输出了两次,原因是在fork()之前调用了一次printf一次,但当调用fork()时,该行数据还在缓冲区中(因为重定向之后为全缓冲),然后讲父进程数据空间复制到子进程中时,该缓冲区数据也被复制到子进程中,此时父进程和子进程各自有了带该行内容的缓冲区.当进程终止时,缓冲区内容被刷新写到文件中. 子进程和父进程之间的区别如下: fork返回值不同(进程ID不同)子进程不继承父进程设置的文件锁子进程的未处理闹钟被清除.子进程的未处理信号集设置为空集.有时候实际用户ID的进程总数超过了系统限制,会导致fork()失败. vfork()函数用于创建一个新进程,而该进程的目的是exec一个新程序.vfork()不会将父进程的地址空间完全复制到子进程中,另一个区别是,vfork()保证子进程先运行,在它调用exec或exit之后父进程才可能被调度运行,当子进程调用这两个函数中的任意一个时,父进程会恢复运行.(如果在调用这两个函数之前子进程依赖父进程的进一步动作会导致死锁.)引用网上的一个说法:为什么会有vfork，因为以前的fork 很傻， 它创建一个子进程时，将会创建一个新的地址空间，并且拷贝父进程的资源，而往往在子进程中会执行exec 调用，这样，前面的拷贝工作就是白费力气了，这种情况下，聪明的人就想出了vfork，它产生的子进程刚开始暂时与父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中运行，所以子进程不能进行写操作，并且在儿子 霸占”着老子的房子时候，要委屈老子一下了，让他在外面歇着（阻塞），一旦儿子执行了exec 或者exit 后，相 于儿子买了自己的房子了，这时候就相当于分家了。","tags":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/tags/apue/"}]},{"title":"递归降序遍历目录结构","date":"2017-03-03T02:06:09.000Z","path":"2017/03/03/递归降序遍历目录结构/","text":"参考apue第四章代码:4.22.c/*此程序用来递归降序遍历文件层次结构,命令行传入一个参数作为起点路径名.*/123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;errno.h&gt;#include\"apue.h\"#include&lt;limits.h&gt;//定义了数据类型的范围.例如INT_MAX宏为该环境下int类型的最大值.#include&lt;dirent.htypedef int Myfunc(const char*,const struct stat*,int);char* path_alloc(size_t*);static Myfunc myfunc;static int myftw(char*,Myfunc*);static int dopath(Myfunc*);static long nreg,ndir,nblk,nchr,nfifo,nslink,nsock,ntot;int main( int argc,char** argv)&#123; int ret; if(argc!=2) err_quit(\"Usage: ftw &lt;starting-pathname&gt;\"); ret=myftw(argv[1],myfunc); ntot=nreg+ndir+nblk+nchr+nfifo+nslink+nsock; if(ntot==0) ntot=1; printf(\"regular files= %7ld,%5.12f %%\\n\",nreg,nreg*100.0/ntot); printf(\"directories = %7ld,%5.12f %%\\n\",ndir,ndir*100.0/ntot); printf(\"block special = %7ld,%5.12f %%\\n\",nblk,nblk*100.0/ntot); printf(\"char special = %7ld,%5.12f %%\\n\",nchr,nchr*100.0/ntot); printf(\"FIFOS = %7ld,%5.12f %%\\n\",nfifo,nfifo*100.0/ntot); printf(\"symbolic links = %7ld,%5.12f %%\\n\",nslink,nslink*100.0/ntot); printf(\"sockets = %7ld,%5.12f %%\\n\",nsock,nsock*100.0/ntot); exit(ret);&#125;/*文件名路径分配函数#ifdef PATH_MAXstatic long pathmax = PATH_MAX;#elsestatic long pathmax = 0;#endifstatic long posix_version = 0;static long xsi_version = 0;/* If PATH_MAX is indeterminate, no guarantee this is adequate */#define PATH_MAX_GUESS 1024char *path_alloc(size_t *sizep) /* also return allocated size, if nonnull */&#123; char *ptr; size_t size; if (posix_version == 0) posix_version = sysconf(_SC_VERSION); if (xsi_version == 0) xsi_version = sysconf(_SC_XOPEN_VERSION); if (pathmax == 0) &#123; /* first time through */ errno = 0; if ((pathmax = pathconf(\"/\", _PC_PATH_MAX)) &lt; 0) &#123; if (errno == 0) pathmax = PATH_MAX_GUESS; /* it's indeterminate */ else err_sys(\"pathconf error for _PC_PATH_MAX\"); &#125; else &#123; pathmax++; /* add one since it's relative to root */ &#125; &#125; /* * Before POSIX.1-2001, we aren't guaranteed that PATH_MAX includes * the terminating null byte. Same goes for XPG3. */ if ((posix_version &lt; 200112L) &amp;&amp; (xsi_version &lt; 4)) size = pathmax + 1; else size = pathmax; if ((ptr = malloc(size)) == NULL) err_sys(\"malloc error for pathname\"); if (sizep != NULL) *sizep = size; return(ptr);&#125;#define FTW_F 1#define FTW_D 2#define FTW_DNR 3#define FTW_NS 4static char* fullpath;static size_t pathlen;static int myftw(char* pathname,Myfunc* func)&#123; fullpath=path_alloc(&amp;pathlen); if(pathlen&lt;=strlen(pathname))&#123; pathlen=strlen(pathname)*2; if((fullpath=realloc(fullpath,pathlen))==NULL) err_sys(\"realloc failed\"); &#125; strcpy(fullpath,pathname); return dopath(func);&#125;/*用来递归调用myfunc来处理路径内的每个文件.static int dopath(Myfunc* func)&#123; struct stat statbuf; struct dirent* dirp; DIR* dp; int ret,n; if(lstat(fullpath,&amp;statbuf)&lt;0) return func(fullpath,&amp;statbuf,FTW_NS); if(S_ISDIR(statbuf.st_mode)==0) return(func(fullpath,&amp;statbuf,FTW_F)); if(ret=func(fullpath,&amp;statbuf,FTW_D)!=0) return ret; n=strlen(fullpath); if(n+NAME_MAX+2&gt;pathlen)&#123; pathlen*=2; if((fullpath=realloc(fullpath,pathlen))==NULL) err_sys(\"realloc failed\"); &#125; fullpath[n++]='/'; fullpath[n]=0; if((dp=opendir(fullpath))==NULL) return func(fullpath,&amp;statbuf,FTW_DNR); while((dirp=readdir(dp))!=NULL)&#123; if(strcmp(dirp-&gt;d_name,\".\")==0||strcmp(dirp-&gt;d_name,\"..\")==0) continue; strcpy(&amp;fullpath[n],dirp-&gt;d_name); if((ret=dopath(func))!=0) break; &#125; fullpath[n-1]=0; closedir(dp); return ret;&#125;/*用来判断输入路径的文件类型,也可能是目录文件*/static int myfunc(const char* pathname,const struct stat* statptr,int type)&#123; switch(type)&#123; case FTW_F: if(S_ISREG(statptr-&gt;st_mode)) nreg++; if(S_ISBLK(statptr-&gt;st_mode)) ndir++; if(S_ISCHR(statptr-&gt;st_mode)) nchr++; if(S_ISFIFO(statptr-&gt;st_mode)) nfifo++; if(S_ISLNK(statptr-&gt;st_mode)) nslink++; if(S_ISSOCK(statptr-&gt;st_mode)) nsock++; break; case FTW_D: ndir++; break; case FTW_DNR: err_ret(\"Can't read directory %s\",pathname); break; case FTW_NS: err_ret(\"stat error for %s\",pathname); break; &#125; return 0;&#125; 运行结果如下:12345678$ /home/wangliang/apue/4.22 /regular files= 389832,70.403768044225 %directories = 61804,11.161819656173 %block special = 0,0.000000000000 %char special = 230,0.041538064218 %FIFOS = 6,0.001083601675 %symbolic links = 101781,18.381677018073 %sockets = 56,0.010113615636 %","tags":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/tags/apue/"}]},{"title":"typedef总结","date":"2017-03-02T02:23:58.000Z","path":"2017/03/02/typedef总结/","text":"今天在apue上看到如下定义:4.22.c12typedef int Myfunc(const char*,const struct stat*,int);static Myfunc myfunc;于是翻了一下c primer 复习了一下typedef的用法:1.自定义变量别名. 2.自定义结构体名称1234typedef struct &#123; float real; float imag;&#125;COMPLEX;3.定义复杂类型:1typedef char(* FRPTC())[5];这句话把frptc声明为一个函数类型,该函数返回一个指向5个元素的char数组的指针.对复杂变量的声明,只要记住在传统声明定义表达式里用类型名代替变量名,然后在开头加上typedef.对于理解复杂声明声明可用的“右左法则”：从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：int (func[5])(int );func右边是一个[]运算符，说明func是具有5个元素的数组；func的左边有一个，说明func的元素是指针（注意这里的不是修饰func，而是修饰func[5]的，原因是[]运算符优先级比高，func先跟[]结合）。跳出这个括号，看右边，又遇到圆括号，说明func数组的元素是函数类型的指针，它指向的函数具有int类型的形参，返回值类型为int。","tags":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/tags/apue/"},{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"apue学习笔记1-exec函数总结","date":"2017-02-27T07:46:57.000Z","path":"2017/02/27/apue学习笔记1-exec函数总结/","text":"这学期开始看apue第三版,并记录相关知识点的笔记.首先复习exec函数的使用. exec函数总共有七个:123456789#include&lt;unistd.h&gt;int execl(const char* pathname,const char* arg0,.../*(char* )0 */);int execv(const char* pathname,char* const argv[]);int execle(const char* pathname,const char* arg0,... /* (char*)0,char* const envp[]*/);int execve(const char* pathname,char* const argv[],char* const envp[]);int execlp(const char* filename,const char* arg0,.../*(char*)0 */);int execvp(const char* filename,char* const argv[]);int fexecve(int fd,char* const argv[],char *const envp[]); 函数之间第一个区别在前4个取路径做参数,后两个函数取文件名做参数,最后一个取文件描述符.也就是说后两个函数可以从环境变量PATH中寻找.第二个区别与参数表有关,以const char* arg0,arg1…传入的为参数列表,需要以空指针做结尾第三个区别环境变量：exec函数族使用了系统默认的环境变量，也可以传入指定的环境变量。这里以“e”（environment）结尾的两个函数execle、execve就可以在envp[]中指定当前进程所使用的环境变量替换掉该进程继承的所以环境变量。这七个只有execve是内核的系统调用,其他的都是库函数.上代码实例:exec.c/*echoall程序用来打印命令行参数和环境表 */123456789101112131415161718#include\"apue.h\"#include&lt;unistd.h&gt;int main(int argc,char** argv)&#123; pid_t pid; char** env_init=&#123;\"USER=unknown\",\"PATH=/tmp\",NULL&#125;; if((pid=fork())&lt;0)&#123; err_sys(\"fork error\"); &#125;else if(pid==0)&#123; if(execle(\"/home/wangliang/bin/echoall\",\"echoall\",\"myarg1\",\"MY ARG2\",(char*)0,env_init)&lt;0) err_sys(\"execle error\"); &#125; if(waitpid(pid,NULL,0)&lt;0) error_sys(\"wait error\"); if((pid=fork)==0) if(execlp(\"echoall\",\"echoall\",\"only 1arg\",(char*)0)&lt;0) err_sys(\"execlp() error\"); exit(0);&#125;","tags":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/tags/apue/"}]},{"title":"利用hexo和githubpage搭建个人博客","date":"2017-02-26T13:03:23.000Z","path":"2017/02/26/利用hexo和github-page-搭建个人博客/","text":"最近博主花了几天的时间终于搭建好了自己的小窝,也是在入坑爬坑的过程弄出来了,参照网上的一些资料教程,自己总结的一套方法如下: 安装node.js Node.js是一个开放源代码、跨平台的、可用于服务器端和网络应用的运行环境，该应用由 C++ 语言写成，在 Node.js 运行时运行。Node.js 提供事件驱动和非阻塞 I/O API，可优化应用程序的吞吐量和规模。这些技术通常被用于实时应用程序。并且它是采用 Google 的 V8 引擎来执行代码，它的大部分基本模块都是用 JavaScript 写成的，包含有一系列内置模块，使得程序可以作为独立服务器运行，从而脱离 Apache HTTP Server 或 IIS 运行。而 npm 也即 Node包管理器（Node Package Manager），它是一个以 Javascript 编写的软件包管理系统，默认环境为 Node.js 。 所以首先得安装node.js和npm,命令如下:12$ sudo apt-get install nodejs$ sudo apt-get install npm或者从官网上下载对应平台的版本进行安装.可以用命令node -v如果出现版本号则安装成功.接下来安装nrm,是npm的资源管理器:1$ sudo npm install nrm -g --registry https://registry.npm.taobao.org接下来设置下载源为淘宝源(防止默认下载源速度慢超时):1$ nrm use taobao可能出现命令未识别,则说明没有全局安装,这时候需要你用ln命令将你下载的可执行文件链接到usr/local/bin/目录下.(如果正常则跳过)1$ ln -s &lt;下载文件&gt; usr/local/bin/&lt;文件名&gt;接下来需要下载hexo,可用如下命令(记住加上-g进行全局安装):1$ sudo npm install hexo -g 安装git工具然后需要安装git工具,需要了解git和如何使用的话可以查阅 git安装教程 搭建博客接下来开始搭建,在自己的主目录下创建Blog目录并生成初始框架:1234$ mkdir Blog &amp;&amp; cd Blog$ hexo init$ hexo generate$ hexo server打开浏览器输入localhost:4000可看到已经生成的初始界面.因为通过hexo server已经运行了本地的服务器进入目录 /home/shiyanlou/Code/Hexo/blog/themes ，下载并解压缩 Next 主题。12$ wget http://labfile.oss.aliyuncs.com/courses/700/next.zip$ unzip next.zip编辑 ~/Blog/config.yml文件,修改主题那一行theme: next(记住选项冒号之后都有空格)可以自行修改其他信息,每次修改后都要执行hexo clean和hexo g命令,关于如何使用hexo和添加自己的文章,修改样式等请参阅: hexo中文官网教程 部署到github如上操作完只是在本地生成了你的静态主页,我们需要传到github仓库里这样别人访问你的仓库就可以自动展示你的博客.首先打开你的github创建一个新的仓库,仓库名格式为:你的git账户名.github.io.如下图:进入Blog目录下,同步你的仓库:1$ git clone [你的仓库的url] 仓库url可以在下图获得:一路顺利后,打开 Blog目录下的config.yml文件,在最下面修改:1234deploy: type: git respository: https://github.com/[你的github用户名]/[你的github用户名].github.io.git branch: master再执行命令:12$ npm install hexo-deployer-git --save$ hexo d然后在浏览器浏览http://[你的github用户名]/github.io至此,初步的搭建已经完成,接下来就是参阅markdown语法和hexo教程来多写文章吧.","tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}]}]