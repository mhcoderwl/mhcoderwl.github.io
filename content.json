[{"title":"fork()和vfork()的总结","date":"2017-03-04T07:04:27.000Z","path":"2017/03/04/fork-和vfork-的总结/","text":"fork()函数可以创建一个新的进程,被称为子进程,子进程获得父进程数据空间,堆和栈的副本.父子进程不共享这些存储空间部分,共享正文段. 看下面一个实例:8.3.c/*打印父子进程的输出*/123456789101112131415161718192021#include \"apue.h\" int globvar= 6;char buf[] = \"a write to stdout\\n\"int main()&#123; int var; pid_t pid; var=88; if(write(STDOUT_FILENO,buf,sizeof(buf)-1)!=sizeof(buf)-1) err_sys(\"write error\"); printf(\"before fork\\n\"); if((pid=fork())&lt;0) err_sys(\"fork error\"); else if(pid==0)&#123; globvar++; var++; &#125;else sleep(2); printf(\"pid=%ld,glob=%d,var=%d\\n\",(long)getpid(),globvar,var); exit(0);&#125; 运行后结果:123456$ gcc 8.3.c -o8.3 -lapue$ ./8.3a write to stdoutbefore forkpid=5423,glob=7,var=89pid=5422,glob=6,var=88一切正常运行,但是如果我们重定向标准输出流之后:1234567$ ./8.3 &gt; temp.out$ cat temp.outa write to stdoutbefore forkpid=5481,glob=7,var=89before forkpid=5480,glob=6,var=88 可以看到printf输出了两次,原因是在fork()之前调用了一次printf一次,但当调用fork()时,该行数据还在缓冲区中(因为重定向之后为全缓冲),然后讲父进程数据空间复制到子进程中时,该缓冲区数据也被复制到子进程中,此时父进程和子进程各自有了带该行内容的缓冲区.当进程终止时,缓冲区内容被刷新写到文件中. 子进程和父进程之间的区别如下: fork返回值不同(进程ID不同)子进程不继承父进程设置的文件锁子进程的未处理闹钟被清除.子进程的未处理信号集设置为空集.有时候实际用户ID的进程总数超过了系统限制,会导致fork()失败. vfork()函数用于创建一个新进程,而该进程的目的是exec一个新程序.vfork()不会将父进程的地址空间完全复制到子进程中,另一个区别是,vfork()保证子进程先运行,在它调用exec或exit之后父进程才可能被调度运行,当子进程调用这两个函数中的任意一个时,父进程会恢复运行.(如果在调用这两个函数之前子进程依赖父进程的进一步动作会导致死锁.)引用网上的一个说法:为什么会有vfork，因为以前的fork 很傻， 它创建一个子进程时，将会创建一个新的地址空间，并且拷贝父进程的资源，而往往在子进程中会执行exec 调用，这样，前面的拷贝工作就是白费力气了，这种情况下，聪明的人就想出了vfork，它产生的子进程刚开始暂时与父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中运行，所以子进程不能进行写操作，并且在儿子 霸占”着老子的房子时候，要委屈老子一下了，让他在外面歇着（阻塞），一旦儿子执行了exec 或者exit 后，相 于儿子买了自己的房子了，这时候就相当于分家了。","tags":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/tags/apue/"}]},{"title":"递归降序遍历目录结构","date":"2017-03-03T02:06:09.000Z","path":"2017/03/03/递归降序遍历目录结构/","text":"参考apue第四章代码:4.22.c/*此程序用来递归降序遍历文件层次结构,命令行传入一个参数作为起点路径名.*/123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;errno.h&gt;#include\"apue.h\"#include&lt;limits.h&gt;//定义了数据类型的范围.例如INT_MAX宏为该环境下int类型的最大值.#include&lt;dirent.htypedef int Myfunc(const char*,const struct stat*,int);char* path_alloc(size_t*);static Myfunc myfunc;static int myftw(char*,Myfunc*);static int dopath(Myfunc*);static long nreg,ndir,nblk,nchr,nfifo,nslink,nsock,ntot;int main( int argc,char** argv)&#123; int ret; if(argc!=2) err_quit(\"Usage: ftw &lt;starting-pathname&gt;\"); ret=myftw(argv[1],myfunc); ntot=nreg+ndir+nblk+nchr+nfifo+nslink+nsock; if(ntot==0) ntot=1; printf(\"regular files= %7ld,%5.12f %%\\n\",nreg,nreg*100.0/ntot); printf(\"directories = %7ld,%5.12f %%\\n\",ndir,ndir*100.0/ntot); printf(\"block special = %7ld,%5.12f %%\\n\",nblk,nblk*100.0/ntot); printf(\"char special = %7ld,%5.12f %%\\n\",nchr,nchr*100.0/ntot); printf(\"FIFOS = %7ld,%5.12f %%\\n\",nfifo,nfifo*100.0/ntot); printf(\"symbolic links = %7ld,%5.12f %%\\n\",nslink,nslink*100.0/ntot); printf(\"sockets = %7ld,%5.12f %%\\n\",nsock,nsock*100.0/ntot); exit(ret);&#125;/*文件名路径分配函数#ifdef PATH_MAXstatic long pathmax = PATH_MAX;#elsestatic long pathmax = 0;#endifstatic long posix_version = 0;static long xsi_version = 0;/* If PATH_MAX is indeterminate, no guarantee this is adequate */#define PATH_MAX_GUESS 1024char *path_alloc(size_t *sizep) /* also return allocated size, if nonnull */&#123; char *ptr; size_t size; if (posix_version == 0) posix_version = sysconf(_SC_VERSION); if (xsi_version == 0) xsi_version = sysconf(_SC_XOPEN_VERSION); if (pathmax == 0) &#123; /* first time through */ errno = 0; if ((pathmax = pathconf(\"/\", _PC_PATH_MAX)) &lt; 0) &#123; if (errno == 0) pathmax = PATH_MAX_GUESS; /* it's indeterminate */ else err_sys(\"pathconf error for _PC_PATH_MAX\"); &#125; else &#123; pathmax++; /* add one since it's relative to root */ &#125; &#125; /* * Before POSIX.1-2001, we aren't guaranteed that PATH_MAX includes * the terminating null byte. Same goes for XPG3. */ if ((posix_version &lt; 200112L) &amp;&amp; (xsi_version &lt; 4)) size = pathmax + 1; else size = pathmax; if ((ptr = malloc(size)) == NULL) err_sys(\"malloc error for pathname\"); if (sizep != NULL) *sizep = size; return(ptr);&#125;#define FTW_F 1#define FTW_D 2#define FTW_DNR 3#define FTW_NS 4static char* fullpath;static size_t pathlen;static int myftw(char* pathname,Myfunc* func)&#123; fullpath=path_alloc(&amp;pathlen); if(pathlen&lt;=strlen(pathname))&#123; pathlen=strlen(pathname)*2; if((fullpath=realloc(fullpath,pathlen))==NULL) err_sys(\"realloc failed\"); &#125; strcpy(fullpath,pathname); return dopath(func);&#125;/*用来递归调用myfunc来处理路径内的每个文件.static int dopath(Myfunc* func)&#123; struct stat statbuf; struct dirent* dirp; DIR* dp; int ret,n; if(lstat(fullpath,&amp;statbuf)&lt;0) return func(fullpath,&amp;statbuf,FTW_NS); if(S_ISDIR(statbuf.st_mode)==0) return(func(fullpath,&amp;statbuf,FTW_F)); if(ret=func(fullpath,&amp;statbuf,FTW_D)!=0) return ret; n=strlen(fullpath); if(n+NAME_MAX+2&gt;pathlen)&#123; pathlen*=2; if((fullpath=realloc(fullpath,pathlen))==NULL) err_sys(\"realloc failed\"); &#125; fullpath[n++]='/'; fullpath[n]=0; if((dp=opendir(fullpath))==NULL) return func(fullpath,&amp;statbuf,FTW_DNR); while((dirp=readdir(dp))!=NULL)&#123; if(strcmp(dirp-&gt;d_name,\".\")==0||strcmp(dirp-&gt;d_name,\"..\")==0) continue; strcpy(&amp;fullpath[n],dirp-&gt;d_name); if((ret=dopath(func))!=0) break; &#125; fullpath[n-1]=0; closedir(dp); return ret;&#125;/*用来判断输入路径的文件类型,也可能是目录文件*/static int myfunc(const char* pathname,const struct stat* statptr,int type)&#123; switch(type)&#123; case FTW_F: if(S_ISREG(statptr-&gt;st_mode)) nreg++; if(S_ISBLK(statptr-&gt;st_mode)) ndir++; if(S_ISCHR(statptr-&gt;st_mode)) nchr++; if(S_ISFIFO(statptr-&gt;st_mode)) nfifo++; if(S_ISLNK(statptr-&gt;st_mode)) nslink++; if(S_ISSOCK(statptr-&gt;st_mode)) nsock++; break; case FTW_D: ndir++; break; case FTW_DNR: err_ret(\"Can't read directory %s\",pathname); break; case FTW_NS: err_ret(\"stat error for %s\",pathname); break; &#125; return 0;&#125; 运行结果如下:12345678$ /home/wangliang/apue/4.22 /regular files= 389832,70.403768044225 %directories = 61804,11.161819656173 %block special = 0,0.000000000000 %char special = 230,0.041538064218 %FIFOS = 6,0.001083601675 %symbolic links = 101781,18.381677018073 %sockets = 56,0.010113615636 %","tags":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/tags/apue/"}]},{"title":"typedef总结","date":"2017-03-02T02:23:58.000Z","path":"2017/03/02/typedef总结/","text":"今天在apue上看到如下定义:4.22.c12typedef int Myfunc(const char*,const struct stat*,int);static Myfunc myfunc;于是翻了一下c primer 复习了一下typedef的用法:1.自定义变量别名. 2.自定义结构体名称1234typedef struct &#123; float real; float imag;&#125;COMPLEX;3.定义复杂类型:1typedef char(* FRPTC())[5];这句话把frptc声明为一个函数类型,该函数返回一个指向5个元素的char数组的指针.对复杂变量的声明,只要记住在传统声明定义表达式里用类型名代替变量名,然后在开头加上typedef.对于理解复杂声明声明可用的“右左法则”：从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：int (func[5])(int );func右边是一个[]运算符，说明func是具有5个元素的数组；func的左边有一个，说明func的元素是指针（注意这里的不是修饰func，而是修饰func[5]的，原因是[]运算符优先级比高，func先跟[]结合）。跳出这个括号，看右边，又遇到圆括号，说明func数组的元素是函数类型的指针，它指向的函数具有int类型的形参，返回值类型为int。","tags":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/tags/apue/"},{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"apue学习笔记1-exec函数总结","date":"2017-02-27T07:46:57.000Z","path":"2017/02/27/apue学习笔记1-exec函数总结/","text":"这学期开始看apue第三版,并记录相关知识点的笔记.首先复习exec函数的使用. exec函数总共有七个:123456789#include&lt;unistd.h&gt;int execl(const char* pathname,const char* arg0,.../*(char* )0 */);int execv(const char* pathname,char* const argv[]);int execle(const char* pathname,const char* arg0,... /* (char*)0,char* const envp[]*/);int execve(const char* pathname,char* const argv[],char* const envp[]);int execlp(const char* filename,const char* arg0,.../*(char*)0 */);int execvp(const char* filename,char* const argv[]);int fexecve(int fd,char* const argv[],char *const envp[]); 函数之间第一个区别在前4个取路径做参数,后两个函数取文件名做参数,最后一个取文件描述符.也就是说后两个函数可以从环境变量PATH中寻找.第二个区别与参数表有关,以const char* arg0,arg1…传入的为参数列表,需要以空指针做结尾第三个区别环境变量：exec函数族使用了系统默认的环境变量，也可以传入指定的环境变量。这里以“e”（environment）结尾的两个函数execle、execve就可以在envp[]中指定当前进程所使用的环境变量替换掉该进程继承的所以环境变量。这七个只有execve是内核的系统调用,其他的都是库函数.上代码实例:exec.c/*echoall程序用来打印命令行参数和环境表 */123456789101112131415161718#include\"apue.h\"#include&lt;unistd.h&gt;int main(int argc,char** argv)&#123; pid_t pid; char** env_init=&#123;\"USER=unknown\",\"PATH=/tmp\",NULL&#125;; if((pid=fork())&lt;0)&#123; err_sys(\"fork error\"); &#125;else if(pid==0)&#123; if(execle(\"/home/wangliang/bin/echoall\",\"echoall\",\"myarg1\",\"MY ARG2\",(char*)0,env_init)&lt;0) err_sys(\"execle error\"); &#125; if(waitpid(pid,NULL,0)&lt;0) error_sys(\"wait error\"); if((pid=fork)==0) if(execlp(\"echoall\",\"echoall\",\"only 1arg\",(char*)0)&lt;0) err_sys(\"execlp() error\"); exit(0);&#125;","tags":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/tags/apue/"}]},{"title":"利用hexo和githubpage搭建个人博客","date":"2017-02-26T13:03:23.000Z","path":"2017/02/26/利用hexo和github-page-搭建个人博客/","text":"最近博主花了几天的时间终于搭建好了自己的小窝,也是在入坑爬坑的过程弄出来了,参照网上的一些资料教程,自己总结的一套方法如下: 安装node.js Node.js是一个开放源代码、跨平台的、可用于服务器端和网络应用的运行环境，该应用由 C++ 语言写成，在 Node.js 运行时运行。Node.js 提供事件驱动和非阻塞 I/O API，可优化应用程序的吞吐量和规模。这些技术通常被用于实时应用程序。并且它是采用 Google 的 V8 引擎来执行代码，它的大部分基本模块都是用 JavaScript 写成的，包含有一系列内置模块，使得程序可以作为独立服务器运行，从而脱离 Apache HTTP Server 或 IIS 运行。而 npm 也即 Node包管理器（Node Package Manager），它是一个以 Javascript 编写的软件包管理系统，默认环境为 Node.js 。 所以首先得安装node.js和npm,命令如下:12$ sudo apt-get install nodejs$ sudo apt-get install npm或者从官网上下载对应平台的版本进行安装.可以用命令node -v如果出现版本号则安装成功.接下来安装nrm,是npm的资源管理器:1$ sudo npm install nrm -g --registry https://registry.npm.taobao.org接下来设置下载源为淘宝源(防止默认下载源速度慢超时):1$ nrm use taobao可能出现命令未识别,则说明没有全局安装,这时候需要你用ln命令将你下载的可执行文件链接到usr/local/bin/目录下.(如果正常则跳过)1$ ln -s &lt;下载文件&gt; usr/local/bin/&lt;文件名&gt;接下来需要下载hexo,可用如下命令(记住加上-g进行全局安装):1$ sudo npm install hexo -g 安装git工具然后需要安装git工具,需要了解git和如何使用的话可以查阅 git安装教程 搭建博客接下来开始搭建,在自己的主目录下创建Blog目录并生成初始框架:1234$ mkdir Blog &amp;&amp; cd Blog$ hexo init$ hexo generate$ hexo server打开浏览器输入localhost:4000可看到已经生成的初始界面.因为通过hexo server已经运行了本地的服务器进入目录 /home/shiyanlou/Code/Hexo/blog/themes ，下载并解压缩 Next 主题。12$ wget http://labfile.oss.aliyuncs.com/courses/700/next.zip$ unzip next.zip编辑 ~/Blog/config.yml文件,修改主题那一行theme: next(记住选项冒号之后都有空格)可以自行修改其他信息,每次修改后都要执行hexo clean和hexo g命令,关于如何使用hexo和添加自己的文章,修改样式等请参阅: hexo中文官网教程 部署到github如上操作完只是在本地生成了你的静态主页,我们需要传到github仓库里这样别人访问你的仓库就可以自动展示你的博客.首先打开你的github创建一个新的仓库,仓库名格式为:你的git账户名.github.io.如下图:进入Blog目录下,同步你的仓库:1$ git clone [你的仓库的url] 仓库url可以在下图获得:一路顺利后,打开 Blog目录下的config.yml文件,在最下面修改:1234deploy: type: git respository: https://github.com/[你的github用户名]/[你的github用户名].github.io.git branch: master再执行命令:12$ npm install hexo-deployer-git --save$ hexo d然后在浏览器浏览http://[你的github用户名]/github.io至此,初步的搭建已经完成,接下来就是参阅markdown语法和hexo教程来多写文章吧.","tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}]}]