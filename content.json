[{"title":"字符串匹配KMP算法","date":"2017-03-28T06:09:15.000Z","path":"2017/03/28/字符串匹配KMP算法/","text":"题目:给定一个待匹配字符串和一个模板字符串,要求找到该串中模板字符串首次出现的位置,如果没有则返回-1. 第一种方法:朴素字符串匹配算法,也就是暴力枚举法,对需要匹配的字符串的每个字符进行一次匹配(在这里一次匹配操作是指两个等长字符串匹配),伪代码如下: 123456NAIVE_STRING_MATCHER(T,P)n=T.lengthm=P.lengthfor s=0 to n-m ifP[1..m]==T[s+1..s+m]return s; 其中第五行的操作记为比较两个等长字符串是否相等.类似于strcmp()函数,这些都很好理解,strcmp()复杂度最高为O(L)(L为待匹配字符串长度).所以整个算法时间复杂度为O(M*N) 第二种方法:KMP算法,为了由于朴素算法每一次的不匹配只移动一个偏移量,这会导致之前的已匹配区域重复匹配,为了能确定不匹配时该移动多少偏移量从而能利用之前的信息,所以我们需要一个next数组,也就是能确定当字符不匹配时,模板字符串向右移多少偏移量(数组的值真正记录的是在该位置前缀后缀最大公共长度,也就是该位置长度减去需要的偏移量).举个例子来说: 假设字符串”ababcba”,模板字符串是”abc”, 首先 a b c b a b a 由于c和a不等(此时位置在b,我们确定的是下一个字符匹配) 于是我们只移动模板2个偏移量,继续匹配 a b a a b c b a b a对应于next[2]=0(2-2); a b c 所以关键就是计算next数组. next数组计算伪代码如下: 123456789101112 COMPUTE_PREFIX_FUNCITION(P) m=P.length let next[1..m] be a new array next[1]=0 k=0 for q=2 to m while k&gt;0 and P[k+1]!=P[q] k=next[k] if P[k+1]==P[q] k=k+1next[q]=k; return next; 算法关键就在于第7-8行,while循环的总时间为O(m),从观察k的值开始,第一,在第5行,k初始值为0,并且增加k的唯一方法是通过第10行的递增操作,该操作在第6-11行的for循环中每次最多执行一次,因为k最多增加m-1次,第二,刚进行for循环时,k小于q,并且每次循环q都会增加,所以k永远小于q因此next[q]永远小于q,所以while循环会使q递减.所以while循环最多迭代m-1次. 下面是之前那道题的两种解法:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/*完成函数int strStr(const string&amp; str1,const string str2)功能,找到str1中子串str2的首字符出现的位置,如果没有则返回0 * 暴力解法O(m*n),也可以利用高效的字符串匹配算法例如KMP算法.*/#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;class Solution&#123;public: int strStr(const string&amp; haystack,const string&amp; needle)&#123; if(needle.empty())return 0; auto pos=haystack.begin(); const int N=haystack.size()-needle.size()+1; for(int i=0;i&lt;N;i++)&#123; int j=i; int k=0; while(j&lt;haystack.size()&amp;&amp;k&lt;needle.size()&amp;&amp;haystack[j]==needle[k])&#123; k++; j++; &#125; if(k==needle.size()) return i; &#125; return -1; &#125;&#125;;/*KMP算法.时间复杂度O(M+N),空间复杂度O(M)*/class Solution&#123;public: //KMP主程序,用预处理过的next数组来控制每次不匹配的偏移量,如果莫一个字符不匹配,那么直接找到needle中某一个字符和haystack的下一个字符匹配,这样永远不会回头,总匹配次数最多为字符串长度. int strStr(const string&amp; haystack,const string&amp; needle)&#123; if(needle.size()==0)return 0; vector&lt;int&gt; next=compute_next(needle); int q=-1; for(int i=0;i&lt;haystack.size();i++)&#123; while(q&gt;-1&amp;&amp;haystack[i]!=needle[q+1]) q=next[q]; if(haystack[i]==needle[q+1]) q++; if(q==(needle.size()-1)) return i-q; &#125;return -1; &#125;//用来计算next数组的算法.具体原理参照算法导论32章. static vector&lt;int&gt; compute_next(const string&amp; s)&#123; vector&lt;int&gt; next(s.size(),-1); if(s.size()==0)return next; int q=-1; for(int i=1;i&lt;s.size();i++)&#123; while(q&gt;-1&amp;&amp;s[i]!=s[q+1])//不匹配时要返回的位置 q=next[q]; if(s[i]==s[q+1])//如果下个字符匹配,那么直接继承之前的已匹配区域. q++; next[i]=q; &#125; return next; &#125;&#125;;int main()&#123; string s1=\"ababcd\"; string needle=\"abc\"; Solution s; cout&lt;&lt;s.strStr(s1,needle)&lt;&lt;endl;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"检查带环链表入口问题","date":"2017-03-24T12:21:11.000Z","path":"2017/03/24/检查带环链表入口问题/","text":"这两天一直在做链表的题目,遇到了一道有环链表的问题,感觉很有趣:题目:给一个链表,如果有回路返回回路开始的节点,没有回路则返回NULL 思路:两个指针一快一慢,fas与slow相遇时,fast已经在圈内循环了n圈,设slow走了n步,则fast走了2s步(fast步数还等于s加上在环上多转的n圈),设环长为r,于是: 2s=s+nr s=nr 设整个链表长L,环入口点与相遇点距离为a,起点到环入口点的距离为x,则: x+a=nr=(n-1)r+r=(n-1)r+L-x x=(n-1)r+(L-x-a) L-x-a为相遇点到环入口点的距离,由此可知,从链表头到环入口点等于n-1圈内环+相遇点到入口点,于是我们可以从head开始另设一个指针slow2,两个慢指针 slow2,两个慢指针每次前进一步,它俩一定会在环入口点相遇*/ 2.2.12.cpp1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;struct ListNode&#123; int val; ListNode* next; ListNode(int x):val(x),next(NULL)&#123;&#125;&#125;;class Solution&#123; ListNode* detectCycle(ListNode* head)&#123; ListNode* slow=head,*fast=head; while(fast&amp;&amp;fast-&gt;next)&#123; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; if(slow==fast)&#123; ListNode* slow2=head; while(slow2!=slow)&#123; slow2=-&gt;slow2-&gt;next; slow=slow-&gt;next; &#125; return slow2; &#125; &#125; return NULL; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"互斥量和避免死锁","date":"2017-03-15T05:17:04.000Z","path":"2017/03/15/互斥量和避免死锁/","text":"互斥量互斥变量是用pthread_mutex_t数据类型表示的,在使用互斥变量之前,必须首先对它进行初始化,可以把它设置为常量PTHREAD_MUTEX_INITIALIZER(只适用于静态分配的互斥量),也可以调用pthread_mutex_init进行初始化,如果动态分配互斥量,在释放内存前需要调用pthread_mutex_destory.1234567#include&lt;pthread.h&gt;int pthread_mutex_init(pthread_mutex_t* restrict mutex, const pthread_mutexattr_t* restrict attr);int pthread_mutex_destory(pthread_mutex_t* mutex);int pthread_mutex_lock(pthread_mutex_t* mutex);int pthread_mutex_trylock(pthread_mutex_t* mutex); //不阻塞,只尝试加锁,若失败返回EBUSY.int pthread_mutex_unlock(pthread_mutex_t* mutex); 死锁如果线程试图对同一个互斥量加锁两次,那么它自身就会陷入死锁状态,但是使用互斥量时,还有其他不太明显的方式也能产生死锁,例如,程序中使用一个以上的互斥量时,如果允许一个线程一直占用第一个互斥量,并且在试图锁住第二个互斥量时处于阻塞状态,但是拥有第二个互斥量的线程也在师徒锁住第一个互斥量.因为两个线程都在相互请求另一个线程拥有的资源,所以这两个线程都无法向前运行,于是就产生死锁.解决办法就是控制互斥量加锁顺序,比如同时要对互斥量A和B加锁,如果所有线程总是在对B加锁前锁住A,那么使用这两个就不会产生死锁.可以参考下面的例子:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;stdlib.h&gt;#include&lt;pthread.h&gt;const int NHASH=29;#define HASH(id) (((unsigned long)id)%NHASH)pthread_mutex_t hashlock=PTHREAD_MUTEX_INITIALIZER;struct foo&#123; int f_count; pthread_mutex_t f_lock; int f_id; struct foo* f_next;//protected by hashlock&#125;;struct foo* fh[NHASH];struct foo* foo_alloc(int id)&#123; struct foo* fp; int idx; if((fp=(struct foo*)malloc(sizeof(struct foo)))!=NULL)&#123; fp-&gt;f_count=1; fp-&gt;f_id=id; if(pthread_mutex_init(&amp;fp-&gt;f_lock,NULL)!=0)&#123; free(fp); return NULL; &#125; idx=HASH(id); pthread_mutex_lock(&amp;hashlock); fp-&gt;f_next=fh[idx]; fh[idx]=fp; pthread_mutex_lock(&amp;fp-&gt;f_lock); pthread_mutex_unlock(&amp;hashlock); &#125; return fp;&#125;void foo_hold(struct foo* fp)&#123; pthread_mutex_lock(&amp;fp-&gt;f_lock); fp-&gt;f_count++; pthread_mutex_unlock(&amp;fp-&gt;f_lock);&#125;struct foo* foo_find(int id)&#123; struct foo* fp; pthread_mutex_lock(&amp;hashlock); for(fp=fh[HASH(id)];fp!=NULL;fp=fp-&gt;f_next)&#123; if(fp-&gt;f_id==id)&#123; fp-&gt;f_count++; break; &#125; &#125; pthread_mutex_unlock(&amp;hashlock); return fp;&#125;//第一个版本的释放函数,严格按照每种互斥量的功能来锁住临界区,由于需要考虑互斥量使用顺序,会导致代码变得复杂.(foo_rele函数中先上锁在观察是否需要修改fh散列表,如果需要修改则必须先解锁在按顺序上锁)void foo_rele(struct foo* fp)&#123; struct foo* tfp; int idx; pthread_mutex_lock(&amp;fp-&gt;f_lock); if(fp-&gt;f_count==1)&#123; pthread_mutex_unlock(&amp;fp-&gt;f_lock); pthread_mutex_lock(&amp;hashlock); pthread_mutex_lock(&amp;fp-&gt;f_lock); if(fp-&gt;f_count!=1)&#123; fp-&gt;f_count--; pthread_mutex_unlock(&amp;fp-&gt;f_lock); pthread_mutex_unlock(&amp;hashlock); return; &#125;else&#123; idx=HASH(fp-&gt;f_id); tfp=fh[idx]; if(tfp==fp)&#123; fh[idx]=fp-&gt;f_next; &#125;else&#123; while(tfp-&gt;f_next!=fp) tfp=tfp-&gt;f_next; tfp-&gt;f_next=fp-&gt;f_next; &#125; &#125; pthread_mutex_unlock(&amp;fp-&gt;f_lock); pthread_mutex_unlock(&amp;hashlock); pthread_mutex_destory(&amp;fp-&gt;f_lock); free(fp); &#125;else&#123; fp-&gt;f_count--; pthread_mutex_unlock(&amp;fp-&gt;f_lock); &#125;&#125;//第二个版本的释放函数.直接用hashlock来锁住对fp的操作,避免了两个互斥量使用的顺序问题.简化了代码.但是线程阻塞的概率会更大,因为hashlock使用的范围更大.需要权衡两者的使用.void foo_rele2(struct foo* fp)&#123; struct foo* tfp; int idx; pthread_mutex_lock(&amp;hashlock); if(--fp-&gt;f_count==0)&#123; idx=HASH(fp-&gt;f_id); tfp=fh[idx]; if(tfp==fp)&#123; fh[idx]=fp-&gt;f_next; &#125;else&#123; while(tfp-&gt;f_next!=fp) tfp=tfp-&gt;f_next; tfp-&gt;f_next=fp-&gt;f_next; &#125; pthread_mutex_unlock(&amp;hashlock); pthread_mutex_destory(&amp;fp-&gt;f_lock); free(fp); &#125;else pthread_mutex_unlock(&amp;hashlock);&#125;","tags":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/tags/apue/"},{"name":"c","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"fork()和vfork()的总结","date":"2017-03-04T07:04:27.000Z","path":"2017/03/04/fork-和vfork-的总结/","text":"fork()函数可以创建一个新的进程,被称为子进程,子进程获得父进程数据空间,堆和栈的副本.父子进程不共享这些存储空间部分,共享正文段. 看下面一个实例:8.3.c/*打印父子进程的输出*/123456789101112131415161718192021#include \"apue.h\" int globvar= 6;char buf[] = \"a write to stdout\\n\"int main()&#123; int var; pid_t pid; var=88; if(write(STDOUT_FILENO,buf,sizeof(buf)-1)!=sizeof(buf)-1) err_sys(\"write error\"); printf(\"before fork\\n\"); if((pid=fork())&lt;0) err_sys(\"fork error\"); else if(pid==0)&#123; globvar++; var++; &#125;else sleep(2); printf(\"pid=%ld,glob=%d,var=%d\\n\",(long)getpid(),globvar,var); exit(0);&#125; 运行后结果:123456$ gcc 8.3.c -o8.3 -lapue$ ./8.3a write to stdoutbefore forkpid=5423,glob=7,var=89pid=5422,glob=6,var=88一切正常运行,但是如果我们重定向标准输出流之后:1234567$ ./8.3 &gt; temp.out$ cat temp.outa write to stdoutbefore forkpid=5481,glob=7,var=89before forkpid=5480,glob=6,var=88 可以看到printf输出了两次,原因是在fork()之前调用了一次printf一次,但当调用fork()时,该行数据还在缓冲区中(因为重定向之后为全缓冲),然后讲父进程数据空间复制到子进程中时,该缓冲区数据也被复制到子进程中,此时父进程和子进程各自有了带该行内容的缓冲区.当进程终止时,缓冲区内容被刷新写到文件中. 子进程和父进程之间的区别如下: fork返回值不同(进程ID不同)子进程不继承父进程设置的文件锁子进程的未处理闹钟被清除.子进程的未处理信号集设置为空集.有时候实际用户ID的进程总数超过了系统限制,会导致fork()失败. vfork()函数用于创建一个新进程,而该进程的目的是exec一个新程序.vfork()不会将父进程的地址空间完全复制到子进程中,另一个区别是,vfork()保证子进程先运行,在它调用exec或exit之后父进程才可能被调度运行,当子进程调用这两个函数中的任意一个时,父进程会恢复运行.(如果在调用这两个函数之前子进程依赖父进程的进一步动作会导致死锁.)引用网上的一个说法:为什么会有vfork，因为以前的fork 很傻， 它创建一个子进程时，将会创建一个新的地址空间，并且拷贝父进程的资源，而往往在子进程中会执行exec 调用，这样，前面的拷贝工作就是白费力气了，这种情况下，聪明的人就想出了vfork，它产生的子进程刚开始暂时与父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中运行，所以子进程不能进行写操作，并且在儿子 霸占”着老子的房子时候，要委屈老子一下了，让他在外面歇着（阻塞），一旦儿子执行了exec 或者exit 后，相 于儿子买了自己的房子了，这时候就相当于分家了。","tags":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/tags/apue/"}]},{"title":"递归降序遍历目录结构","date":"2017-03-03T02:06:09.000Z","path":"2017/03/03/递归降序遍历目录结构/","text":"参考apue第四章代码:4.22.c/*此程序用来递归降序遍历文件层次结构,命令行传入一个参数作为起点路径名.*/123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;errno.h&gt;#include\"apue.h\"#include&lt;limits.h&gt;//定义了数据类型的范围.例如INT_MAX宏为该环境下int类型的最大值.#include&lt;dirent.htypedef int Myfunc(const char*,const struct stat*,int);char* path_alloc(size_t*);static Myfunc myfunc;static int myftw(char*,Myfunc*);static int dopath(Myfunc*);static long nreg,ndir,nblk,nchr,nfifo,nslink,nsock,ntot;int main( int argc,char** argv)&#123; int ret; if(argc!=2) err_quit(\"Usage: ftw &lt;starting-pathname&gt;\"); ret=myftw(argv[1],myfunc); ntot=nreg+ndir+nblk+nchr+nfifo+nslink+nsock; if(ntot==0) ntot=1; printf(\"regular files= %7ld,%5.12f %%\\n\",nreg,nreg*100.0/ntot); printf(\"directories = %7ld,%5.12f %%\\n\",ndir,ndir*100.0/ntot); printf(\"block special = %7ld,%5.12f %%\\n\",nblk,nblk*100.0/ntot); printf(\"char special = %7ld,%5.12f %%\\n\",nchr,nchr*100.0/ntot); printf(\"FIFOS = %7ld,%5.12f %%\\n\",nfifo,nfifo*100.0/ntot); printf(\"symbolic links = %7ld,%5.12f %%\\n\",nslink,nslink*100.0/ntot); printf(\"sockets = %7ld,%5.12f %%\\n\",nsock,nsock*100.0/ntot); exit(ret);&#125;/*文件名路径分配函数#ifdef PATH_MAXstatic long pathmax = PATH_MAX;#elsestatic long pathmax = 0;#endifstatic long posix_version = 0;static long xsi_version = 0;/* If PATH_MAX is indeterminate, no guarantee this is adequate */#define PATH_MAX_GUESS 1024char *path_alloc(size_t *sizep) /* also return allocated size, if nonnull */&#123; char *ptr; size_t size; if (posix_version == 0) posix_version = sysconf(_SC_VERSION); if (xsi_version == 0) xsi_version = sysconf(_SC_XOPEN_VERSION); if (pathmax == 0) &#123; /* first time through */ errno = 0; if ((pathmax = pathconf(\"/\", _PC_PATH_MAX)) &lt; 0) &#123; if (errno == 0) pathmax = PATH_MAX_GUESS; /* it's indeterminate */ else err_sys(\"pathconf error for _PC_PATH_MAX\"); &#125; else &#123; pathmax++; /* add one since it's relative to root */ &#125; &#125; /* * Before POSIX.1-2001, we aren't guaranteed that PATH_MAX includes * the terminating null byte. Same goes for XPG3. */ if ((posix_version &lt; 200112L) &amp;&amp; (xsi_version &lt; 4)) size = pathmax + 1; else size = pathmax; if ((ptr = malloc(size)) == NULL) err_sys(\"malloc error for pathname\"); if (sizep != NULL) *sizep = size; return(ptr);&#125;#define FTW_F 1#define FTW_D 2#define FTW_DNR 3#define FTW_NS 4static char* fullpath;static size_t pathlen;static int myftw(char* pathname,Myfunc* func)&#123; fullpath=path_alloc(&amp;pathlen); if(pathlen&lt;=strlen(pathname))&#123; pathlen=strlen(pathname)*2; if((fullpath=realloc(fullpath,pathlen))==NULL) err_sys(\"realloc failed\"); &#125; strcpy(fullpath,pathname); return dopath(func);&#125;/*用来递归调用myfunc来处理路径内的每个文件.static int dopath(Myfunc* func)&#123; struct stat statbuf; struct dirent* dirp; DIR* dp; int ret,n; if(lstat(fullpath,&amp;statbuf)&lt;0) return func(fullpath,&amp;statbuf,FTW_NS); if(S_ISDIR(statbuf.st_mode)==0) return(func(fullpath,&amp;statbuf,FTW_F)); if(ret=func(fullpath,&amp;statbuf,FTW_D)!=0) return ret; n=strlen(fullpath); if(n+NAME_MAX+2&gt;pathlen)&#123; pathlen*=2; if((fullpath=realloc(fullpath,pathlen))==NULL) err_sys(\"realloc failed\"); &#125; fullpath[n++]='/'; fullpath[n]=0; if((dp=opendir(fullpath))==NULL) return func(fullpath,&amp;statbuf,FTW_DNR); while((dirp=readdir(dp))!=NULL)&#123; if(strcmp(dirp-&gt;d_name,\".\")==0||strcmp(dirp-&gt;d_name,\"..\")==0) continue; strcpy(&amp;fullpath[n],dirp-&gt;d_name); if((ret=dopath(func))!=0) break; &#125; fullpath[n-1]=0; closedir(dp); return ret;&#125;/*用来判断输入路径的文件类型,也可能是目录文件*/static int myfunc(const char* pathname,const struct stat* statptr,int type)&#123; switch(type)&#123; case FTW_F: if(S_ISREG(statptr-&gt;st_mode)) nreg++; if(S_ISBLK(statptr-&gt;st_mode)) ndir++; if(S_ISCHR(statptr-&gt;st_mode)) nchr++; if(S_ISFIFO(statptr-&gt;st_mode)) nfifo++; if(S_ISLNK(statptr-&gt;st_mode)) nslink++; if(S_ISSOCK(statptr-&gt;st_mode)) nsock++; break; case FTW_D: ndir++; break; case FTW_DNR: err_ret(\"Can't read directory %s\",pathname); break; case FTW_NS: err_ret(\"stat error for %s\",pathname); break; &#125; return 0;&#125; 运行结果如下:12345678$ /home/wangliang/apue/4.22 /regular files= 389832,70.403768044225 %directories = 61804,11.161819656173 %block special = 0,0.000000000000 %char special = 230,0.041538064218 %FIFOS = 6,0.001083601675 %symbolic links = 101781,18.381677018073 %sockets = 56,0.010113615636 %","tags":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/tags/apue/"}]},{"title":"typedef总结","date":"2017-03-02T02:23:58.000Z","path":"2017/03/02/typedef总结/","text":"今天在apue上看到如下定义:4.22.c12typedef int Myfunc(const char*,const struct stat*,int);static Myfunc myfunc;于是翻了一下c primer 复习了一下typedef的用法:1.自定义变量别名. 2.自定义结构体名称1234typedef struct &#123; float real; float imag;&#125;COMPLEX;3.定义复杂类型:1typedef char(* FRPTC())[5];这句话把frptc声明为一个函数类型,该函数返回一个指向5个元素的char数组的指针.对复杂变量的声明,只要记住在传统声明定义表达式里用类型名代替变量名,然后在开头加上typedef.对于理解复杂声明声明可用的“右左法则”：从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：int (func[5])(int );func右边是一个[]运算符，说明func是具有5个元素的数组；func的左边有一个，说明func的元素是指针（注意这里的不是修饰func，而是修饰func[5]的，原因是[]运算符优先级比高，func先跟[]结合）。跳出这个括号，看右边，又遇到圆括号，说明func数组的元素是函数类型的指针，它指向的函数具有int类型的形参，返回值类型为int。","tags":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/tags/apue/"},{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/tags/c-c/"}]},{"title":"apue学习笔记1-exec函数总结","date":"2017-02-27T07:46:57.000Z","path":"2017/02/27/apue学习笔记1-exec函数总结/","text":"这学期开始看apue第三版,并记录相关知识点的笔记.首先复习exec函数的使用. exec函数总共有七个:123456789#include&lt;unistd.h&gt;int execl(const char* pathname,const char* arg0,.../*(char* )0 */);int execv(const char* pathname,char* const argv[]);int execle(const char* pathname,const char* arg0,... /* (char*)0,char* const envp[]*/);int execve(const char* pathname,char* const argv[],char* const envp[]);int execlp(const char* filename,const char* arg0,.../*(char*)0 */);int execvp(const char* filename,char* const argv[]);int fexecve(int fd,char* const argv[],char *const envp[]); 函数之间第一个区别在前4个取路径做参数,后两个函数取文件名做参数,最后一个取文件描述符.也就是说后两个函数可以从环境变量PATH中寻找.第二个区别与参数表有关,以const char* arg0,arg1…传入的为参数列表,需要以空指针做结尾第三个区别环境变量：exec函数族使用了系统默认的环境变量，也可以传入指定的环境变量。这里以“e”（environment）结尾的两个函数execle、execve就可以在envp[]中指定当前进程所使用的环境变量替换掉该进程继承的所以环境变量。这七个只有execve是内核的系统调用,其他的都是库函数.上代码实例:exec.c/*echoall程序用来打印命令行参数和环境表 */123456789101112131415161718#include\"apue.h\"#include&lt;unistd.h&gt;int main(int argc,char** argv)&#123; pid_t pid; char** env_init=&#123;\"USER=unknown\",\"PATH=/tmp\",NULL&#125;; if((pid=fork())&lt;0)&#123; err_sys(\"fork error\"); &#125;else if(pid==0)&#123; if(execle(\"/home/wangliang/bin/echoall\",\"echoall\",\"myarg1\",\"MY ARG2\",(char*)0,env_init)&lt;0) err_sys(\"execle error\"); &#125; if(waitpid(pid,NULL,0)&lt;0) error_sys(\"wait error\"); if((pid=fork)==0) if(execlp(\"echoall\",\"echoall\",\"only 1arg\",(char*)0)&lt;0) err_sys(\"execlp() error\"); exit(0);&#125;","tags":[{"name":"apue","slug":"apue","permalink":"http://yoursite.com/tags/apue/"}]},{"title":"利用hexo和githubpage搭建个人博客","date":"2017-02-26T13:03:23.000Z","path":"2017/02/26/利用hexo和github-page-搭建个人博客/","text":"最近博主花了几天的时间终于搭建好了自己的小窝,也是在入坑爬坑的过程弄出来了,参照网上的一些资料教程,自己总结的一套方法如下: 安装node.js Node.js是一个开放源代码、跨平台的、可用于服务器端和网络应用的运行环境，该应用由 C++ 语言写成，在 Node.js 运行时运行。Node.js 提供事件驱动和非阻塞 I/O API，可优化应用程序的吞吐量和规模。这些技术通常被用于实时应用程序。并且它是采用 Google 的 V8 引擎来执行代码，它的大部分基本模块都是用 JavaScript 写成的，包含有一系列内置模块，使得程序可以作为独立服务器运行，从而脱离 Apache HTTP Server 或 IIS 运行。而 npm 也即 Node包管理器（Node Package Manager），它是一个以 Javascript 编写的软件包管理系统，默认环境为 Node.js 。 所以首先得安装node.js和npm,命令如下:12$ sudo apt-get install nodejs$ sudo apt-get install npm或者从官网上下载对应平台的版本进行安装.可以用命令node -v如果出现版本号则安装成功.接下来安装nrm,是npm的资源管理器:1$ sudo npm install nrm -g --registry https://registry.npm.taobao.org接下来设置下载源为淘宝源(防止默认下载源速度慢超时):1$ nrm use taobao可能出现命令未识别,则说明没有全局安装,这时候需要你用ln命令将你下载的可执行文件链接到usr/local/bin/目录下.(如果正常则跳过)1$ ln -s &lt;下载文件&gt; usr/local/bin/&lt;文件名&gt;接下来需要下载hexo,可用如下命令(记住加上-g进行全局安装):1$ sudo npm install hexo -g 安装git工具然后需要安装git工具,需要了解git和如何使用的话可以查阅 git安装教程 搭建博客接下来开始搭建,在自己的主目录下创建Blog目录并生成初始框架:1234$ mkdir Blog &amp;&amp; cd Blog$ hexo init$ hexo generate$ hexo server打开浏览器输入localhost:4000可看到已经生成的初始界面.因为通过hexo server已经运行了本地的服务器进入目录 /home/shiyanlou/Code/Hexo/blog/themes ，下载并解压缩 Next 主题。12$ wget http://labfile.oss.aliyuncs.com/courses/700/next.zip$ unzip next.zip编辑 ~/Blog/config.yml文件,修改主题那一行theme: next(记住选项冒号之后都有空格)可以自行修改其他信息,每次修改后都要执行hexo clean和hexo g命令,关于如何使用hexo和添加自己的文章,修改样式等请参阅: hexo中文官网教程 部署到github如上操作完只是在本地生成了你的静态主页,我们需要传到github仓库里这样别人访问你的仓库就可以自动展示你的博客.首先打开你的github创建一个新的仓库,仓库名格式为:你的git账户名.github.io.如下图:进入Blog目录下,同步你的仓库:1$ git clone [你的仓库的url] 仓库url可以在下图获得:一路顺利后,打开 Blog目录下的config.yml文件,在最下面修改:1234deploy: type: git respository: https://github.com/[你的github用户名]/[你的github用户名].github.io.git branch: master再执行命令:12$ npm install hexo-deployer-git --save$ hexo d然后在浏览器浏览http://[你的github用户名]/github.io至此,初步的搭建已经完成,接下来就是参阅markdown语法和hexo教程来多写文章吧.","tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}]}]